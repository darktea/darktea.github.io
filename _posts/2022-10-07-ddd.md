---
title: DDD Notes
date: 2022-10-07 00:00:00 +0800
categories: [notes]
tags: [DDD]
---

## DDD 总览

在深入 DDD 细节之前，先从对 DDD 的基本思想进行概括。

* Problem Space：当面对问题时，DDD 首先强调的是定义「问题空间」
  * 也就是先把精力集中在「问题域」（Problem Domain）上
  * 把大的「领域」（Domain）分解为多个小的「子域」（Subdomain）
* Solution Space：一旦理解了「问题域」，就可以使用 DDD 的「战略模式」实现技术上的「解决方案」
  * 「战略模式」能使得产品的「核心部分」和「通用区域」分割开了，避免修改「核心部分」时影响到整个产品
  * 产品的「核心部分」（极其复杂+频繁变动）必须是基于「模型」的
  * DDD 的「战术模式」（同时配合 Model-Driven Design）帮助开发人员针对 Domain，创建出代码级别的「模型」。总之：
    * 「模型」是分离复杂性，让「软件」能够持续进化的关键
    * 「模型」也是在「问题域」上和其他开发人员以及领域专家沟通的关键

我们准备分 3 部分来介绍 DDD：

* DDD 基础理念，以及 DDD 的原则与实践
* DDD 的「战略模式」（strategic pattern）
* DDD 的「战术模式」（tactical pattern）

## DDD 原则与实践

本节，以及随后的几个小节，介绍第一部分：DDD 的原则和实践。

### 复杂问题域的挑战

进入 DDD 之前，先说明一下存在的问题：

* 反模式：「大泥球」模式。领域复杂性和技术复杂性被混合在一起，导致了软件维护困难
* 「通用语言」和「问题域知识」的缺乏使得软件不能和「业务逻辑」对应，导致了「大泥球」模式。也使得「分析模式」和「代码」之间转换的代价极其高昂

>「分析模式」是一种表现形式，使得非技术人员能够理解软件的逻辑和结构

* 如果不围绕着「问题域」来设计和和组织软件的开发，会导致复杂度快速提升

> 什么是「问题域」？
>
> 「问题域」指的是当前正在构建的软件的主题。DDD 强调的是在构建大型复杂软件时，必须把对领域的关注放在最高的位置。
>
> 例如，在构架一个医疗相关的软件时，不是要去了解怎么成为一个医生，而是要专注于该领域的术语，不同的相关方看待病人的不同方式，以及医生需要收集哪些信息，并且怎么处理这些信息。

### DDD 解决复杂问题域的模式

* DDD 的「战略模式」：The strategic patterns of DDD distill the **problem domain** and shape the architecture of an application
  * 识别出「核心域」，找到软件真正的价值所在，「核心域」才是真正值得投资的部分。避免「大泥球」模式的出现
  * 在「解空间」中，为每个「子领域」（subdomain）构建一个「软件模型」来和「业务逻辑」对齐。不过由于不同的「子领域」的重要性及复杂度不同，所付出的实现代价也就不同（例如，不复杂的子领域，甚至可以不用面向对象模型来构建）
  * 既然「模型」是由「领域专家」和「开发人员」合作建立起来的，所以一套不断进化的「通用语言」（UL）是必须的。「分析模型」中的新概念会通过 UL 反馈到「代码」中，「代码」中的概念也会被复制到 UL 中
  * 「模型」属于「界限上下文」（Bounded Context），「界限上下文」定义了「模型」的应用范围，同时确保了「模型」的完整性。这种围绕着模型的保护边界可以防止软件变成「大泥球」模式（「模型」被隔离在自己的边界内变化，避免把复杂度扩展到其他「上下文」）
  * Context Map 用来表现处于不同「上下文」中的「模型」的关系
* DDD 的「战术模式」：其实就是一系列的「模式」，这些「模式」用来帮助开发人员更有效的创建「边界上下文」中的「模型」（很多时候是针对代码层面）
  * 这些「模式」从细节上关注如何来管理「问题空间」的复杂度和「解空间」的复杂度
  * 「问题空间」：把「问题域」提炼成可管理的「子域」；并识别出各个「子域」的重要性
  * 「解空间」：包含了各种「模式」，这些「模式」用于塑造软件的「架构」，使得「软件」更容易的被管理

> 是否可以这样理解：「战略模式」针对「问题空间」；「战术模式」针对「解空间」？

### DDD 的原则与实践

原则：

* 集中在「核心域」（Core Subdomain）
* 协作：需要「领域专家」和「开发人员」的协作，以及相互学习
* 通过探索和试验来创建「模型」：「分析模型」和「代码模型」的不断迭代和相互反馈
* 交流：必须创建 UL 来保障正确而高效的交流
* 理解「模型」的应用范围（「模型」处于「上下文边界」内）
* 「模型」保持不断进化

### DDD 的常见误区

误区：

* 「战术模式」是 DDD 的关键
* DDD 是一种 Framework
* DDD 是银弹

## 对问题域进行提取

* 从「问题域」提取出建设「模型」所需要的知识
  * 知识提取必须和「业务专家」合作才能成功：「业务专家」+「开发团队」+「Use Cases」=> 满足用例的「模型」
  * 「领域知识」可能比技术本身还要重要：开发人员要具备有使用简单术语向客户描绘「业务域」中复杂概念的能力
* 完成「知识提取」并达成共识的一个标志是产出 UL（通用语言）
* 「利益方」和「业务专家」是不同的角色
  * 「利益方」更多的是描绘对系统的愿景、系统的输入输出；「开发团队」把这些信息收集起来形成「Use Cases」
  * 「业务专家」和「开发团队」一起合作进行「知识提取」，并产出「模型」
* 一些有用的手段：
  * 「手绘的草图」
  * CRC 卡（类职责合作卡）：类名及其蕴含的概念+类的职责+类之间的合作关系
  * 避免过早的对模型中的概念命名
  * 在和「业务专家」交流时可以使用 BDD（GWT，Given-When-Then）。也就是对一个特性进行描绘可以分解为：条件（Given）、场景中包含的事件（When）、输出结果（Then）
  * 利用快速原型
  * Impact Mapping（理解为业务事件「影响力」）：利用业务事件的「影响力」来更好的理解业务
    * 例如：利用「思维导图」的形式展示出「提高自行车销量 25%」这个业务事件的影响力
  * 业务模型图
  * ......

## Model Driven Design

### Domain Model

* Domain Model（领域模型） 是「解空间」的概念；对应的，Domain （领域）是「问题空间」的概念
  * 「代码模型」是「领域模型」的主要表现形式
* DDD 强调「代码模型」（也就是实现）需要和「分析模型」（也就是设计）保持一致，这种一致需要靠 UL（通用语言）来保证
  * 「分析模型」也叫做「业务模型」。「分析模型」用于对「问题域」的理解
  * 如果「开发团队」发现代码和「分析模式」存在不一致，需要立即和「领域专家」沟通解决：code is model；code is truth
  * 「模型驱动设计」和 DDD（领域驱动设计）的区别就是前者注重实现，后者注重语言、协作和知识

### 通用语言

* 「通用语言」是 DDD 的基础（既然 DDD 强调「业务专家」和「开发团队」直接的沟通和协作）
* 从「实际例子」中来提取 UL。但注意：
  * 不要在描述「实际例子」时使用「技术术语」
  * 不要在描述「实际例子」时转到「解空间」，而是要专注在「问题空间」
  * 尽量避免使用「过载」的词语，例如：service，manager，policy 等等
  * 专注于「核心域」，首先在「核心域」使用「模型驱动」并建立 UL；不需要把太多精力放到「通用域」和「支撑域」

## 领域模型实现模式

正如前面提到的，并不是所有的 Domain（或者说 Subdomain）的复杂度和重要性都是相同的，所以，在对各个 Subdomain 进行建模时，我们可以采用不同的「领域模型的实现模式」。下面各个小节给出不同的「实现模式」，并给出它们的适用场景。

另外，也先明确一下「领域层」（Domain Layer）在领域模型实现中的作用：在代码构架中把「领域模型」和代码的其他部分隔离开，从而实现对「复杂度」的隔离。

### 领域模型模式

* 领域模型模式（Domain Model Pattern）是面向对象模型，适用于「业务逻辑」复杂的领域（Subdomain）
* 值得注意的是，「领域模型模式」的建模过程中不需要考虑数据的持久化，也就是说，不需要涉及到「数据库建模」
* 「领域模型」可以被看成是当前领域的「概念层」。事物存在于该模型中，并与其他事物相互关联作用
* 「模型」就是数据+行为；建模是应该把注意力集中在「**行为**」上，而不要去关注「模型」的**状态**

> 特别注意的是：只有在对「核心领域」建模时，才使用「领域模型模式」；对于「业务逻辑」不复杂的其他 Subdomain（例如：通用域，支撑域），不一定要使用「领域模型模式」，可能使用「贫血领域模型」或者「表模型模式」就够了

### 事务脚本模式

* 「事务脚本」使用的是「过程式」的编程方式，而不是面向对象的编程方式
* 「事务脚本」的优点是上手比较简单；但当业务逻辑复杂度增大的时候，重叠的功能逐渐增多，「事务脚本」就会遇到管理困难的问题

> 当「业务逻辑」复杂度增高时，需要从「事务脚本」向「领域模型」的方向进行重构

### 表模型模式

* 「表模型模式」把「对象模型」对应到「数据库模型」上：
  * 单个「对象模型」表示数据库中的单个「表」或「视图」
* 「表模型模式」特别适用于「数据库驱动设计」（Database-Driven Design）方法
* 对于被「有边界的上下文」隔离出来的简单「领域」，并且该领域的**数据形式很简单**的话，可以考虑使用「表模型模式」；这样做的优点是更容易掌控

> 当「对象模型」和「数据库模型」开始出现分歧时，需要从「表模型」向「领域模型」方向进行重构

### Active Record

* 「Active Record 模式」是「表模型模式」的变体；它不是把「对象模型」对应到「表」，而是把「对象模型」对应到「表的行」
  * 单个「对象模型」表示「表中单独一行」在某个时刻的状态
* 在使用「Active Record 模式」时，每个「业务对象」都负责其自身的持久化，及其相关的业务逻辑
* 「Active Record 模式」适用于「对象模型」和「数据模型」一一对应的场景

### 贫血领域模型

* 「贫血领域模型」和「领域模型」的共同点是都使用了「领域对象」。但和「领域模型」不同，「贫血领域模型」中的「领域对象」不包含**行为**，仅仅包含了数据
* 「贫血领域模型」最大的缺点也就是其采用了类似「过程式」的程序风格（类似「事务脚本」模式）
  * 「过程式」的程序风格最大的问题是违反了所谓的「Tell，Don't Ask」原则。如果按照该原则，「对象」只会告诉客户端该「对象」能做什么，不能做什么；而不能把「对象」自己的状态暴露给客户端；不能让客户端去根据「对象」的状态来实施动作
* 「贫血领域模型」中的「模型对象」被剥夺了「业务逻辑」，仅仅存储了数据
* 「贫血领域模型」适用于「业务逻辑」比较简单的场景；或者是不擅长「面向对象」开发的「开发团队」

### 贫血领域模型和函数式编程

* 在使用「函数式编程」时，「贫血领域模型」不再是「反模式」？
* 尽管表面上看起来，「贫血领域模型」剔除掉了把「领域概念」表示成「对象」的能力，从而和「领域模型」强调的与「领域专家」进行对话有所冲突。但事实上，使用「函数编程」+「贫血领域模型」依然可以做到和「领域专家」进行有意义的对话？

> 这部分内容还需要进一步的理解

## 有界上下文

### 有界上下文的必要性

* 理想的情况是一个 Subdomain 对应一个 Model；但事实上，一个 Subdomain 可能有多个 Model，一个 Model 也可能横跨多个 Subdomain
* 但如果不清楚 Model 适用于哪个「上下文」，Model 就会变得越来越模糊，Model 的概念和逻辑也会越来越混乱
* 所以需要保护 Model 的「完整性」，并在代码中清晰的定义 Model 的职责的边界：Bounded Context（有界上下文）
  * 把一个 Model 绑定在特定的「上下文」也就是「有界上下文」
* 「有界上下文」对管理「解空间」的复杂度至关重要；使用「有界上下文」也是成功实施 DDD 的关键
* 我们倾向于使用多个小 Model，而非单一大 Model
  * DDD 鼓励把一个大的系统分割为多个子系统，尽量避免把单个 Model 用于整个系统
  * 因为，如果使用单个 Model，单个 Model 过于庞大，容纳了太多的「领域概念」，随着系统的不断增长，单个 Model 会更加复杂，变得难于管理
  * 多个「开发团队」工作在单个 Model，随着系统的增长，工作成本越来越高，效率越来越低
  * 很多时候，同样的「名称」在不同的「上下文」其实代表了不同的含义，所以多个小 Model 比单一大 Model 更加有效
    * 类似的，「问题域」中的单个「实体」也可能代表不同的「领域概念」
* 「子域」和「有界上下文」的区别
  * 「子域」（Subdomain）是「问题空间」的概念，「子域」用于在「问题域」打破复杂度
  * 建立「领域模型」的目的是满足「子域」的「User Cases」。现实中，一个「子域」可能包含多个 Model，单个Model 也可能横跨多个「子域」（常见于涉及到遗留系统的场景）
  * 「有界上下文」是「解空间」的概念；「有界上下文」是在应用软件内部对「模型」进行分割的具体技术实现

### 有界上下文的实现

* 「有界上下文」是代码相关的：「有界上下文」从展示层，到领域逻辑层，到持久层，到数据存储层进行了代码级别的垂直切分
* 根据各个「有界上下文」的不同，可以采用不同的「架构模式」

> 说白了，就是对系统「上下游」关系的梳理

## 上下文映射

* 上下文映射（Context Map）：其职责是确保系统各个上下文之间的边界被明确定义，并且每个团队都理解他们之间的契合点
* 很多时候，Context Map 都不是文档，就是手绘的图
* Context Map 表示的是现实的状态，而不是未来的理想状态

* 上下文关系之间关系的种类：
  * 防止损坏层：在集成其他子系统时，为了避免其他子系统中的模型破坏当前系统的模型，增加防止损坏层来进行隔离。该层主要是做转换工作
  * 共享内核：在具有大量交错的独立「有界上下文」中，提取出一个供 2 个团队共享的模型是一种交接方法
    * 该方案的风险在于：「共享模型」中的任何修改都可能影响到 2 个团队，需要测试充分后才能变更
  * 开放宿主服务（Open Host Service）：当前模型的多个使用者可以共享一套模型转换逻辑，可以把这层转换逻辑提取出来形成「开放宿主服务」供多个使用者使用
  * Separate Ways（互不相干）：有时候系统之间的沟通互不相干也是一种选择，而是采用非系统的手工方式来沟通
  * Partnership：2 个团队协作工作，2 个系统的发布保持同步
  * 上下游关系：又分为 2 种「上下游」关系，「客户-供应商」关系和「遵从」关系（Conformist）

> 在绘制「上下文映射」图时，可以标明「上下游」，以及「上下文」之间是哪种关系

## 应用架构

* DDD 不限制具体使用哪种「应用架构」，DDD 强调的是：无论使用哪种「应用架构」都要有对「领域逻辑」进行隔离的能力
* 「应用架构」要能够分离「技术复杂度」和「领域复杂度」
* 「应用架构」要能够对「复杂度」进行抽象和封装
* 可以考虑使用「分层架构」。其中关键有 2 层：
  * 「领域层」包含所有核心业务逻辑；「领域层」不和任何技术实现相关，也不需要了解任何持久化的具体实现
  * 「应用层」表示各种外部要访问的用例；用「应用层」包裹住「领域层」
  * 其他层次重要性比这 2 个核心层要低，只是起到支持作用

* 「领域层」不依赖任何其他层次；「应用层」只依赖领域层
  * 例如，如果「领域层」中的「领域对象」需要持久化，实现的时候不能把「领域层」相关的代码和「持久化」的代码耦合在一起，而是从「应用层」来暴露一个用于存储「领域对象」的接口来实现（可以使用「依赖倒置」的方式来达到这个目的）

* 「应用层」表示应用程序的用例和行为；「应用层」把应用的逻辑代理给「领域层」和「基础架构层」来实现
  * 「应用层」隐藏所有「领域层」的工作细节
  * 「应用层」的工作可能会依赖除了「领域层」之外的其他层（例如：「基础架构层」），但代码实现上又不能依赖其他层，所以会采用「依赖倒置」的方式编码
  * 从某种意义上来说，「应用层」就是「领域层」的「防止损坏层」，避免技术实现细节的变动影响到「领域逻辑」

* 「基础架构层」（Infrastructural Layer）包含整个应用程序工作的技术实现细节；「基础架构层」完全不涉及任何「业务逻辑」和「模型行为」
  * 此外，「基础架构层」可以为日志，安全，通知，以及和其他「有界上下文」或「应用程序」的集成提供能力

* 「跨层通讯层」：跨层间通讯的时候，不要直接传输「领域对象」而是要遵从低层次的协议，用 DTO 对象进行传输
* 既然「领域层」不依赖任何其他层次，测试时，可以把「领域层」和其他层隔离开来，进行单独的测试
* 多个「有界上下文」不要通过「共享数据库」数据的方式来通讯，而是应该遵循「分层架构」，由「应用层」暴露接口来实现「有界上下文」之间的通讯

### 应用服务层

最后在专门说明一下「应用服务」（Application Service），属于上面提到的「应用层」。

* 「应用服务」对外暴露该应用程序可用的业务能力，而这些业务能力是由系统需要满足的「业务用例」所定义的
* 「应用服务」对「领域层」进行抽象，并对其复杂性进行封装
* 「应用服务」只包含「应用逻辑」，而不应该存在任何「领域逻辑」
* 「应用服务」需要跟上最新的技术潮流，并保持精简；但不会依赖任何程序框架或技术
* 「应用服务」的功能有点像 MVC 模式中「控制器」，都是「过程式」而非「面向对象」的代码
* 「应用服务」也可以用于验证该「子域」是否真的需要一个「领域模型」：如果「应用服务」的 API 过于简单（只是简单的增删改查），那么未必需要「领域模型」，用「事务脚本」之类的方案可能就够了

再说明一下应用层的具体逻辑。应用层逻辑就是用来满足「业务 User Cases」的一个工作流，工作流中包含多个步骤。这些步骤有：

* 从持久层（Database）拿出「领域对象」
* 把用户的输入翻译成「领域层」能理解的「领域对象」
* 把用户请求转给「领域层」执行「业务逻辑」，拿到执行结果，并返回业务结果给用户
* 另外也包含需要调用「基础架构层」来工作的步骤（消息，日志，通知，认证等）

## DDD 的常见问题

* 过分强调「战术模式」：技术人员倾向于各种「技术模式」并埋头写代码；而事实上，一旦问题定义清楚，写代码真心不是大问题
* 对所有的「有界上下文」使用同样的「架构」；而事实上，对复杂度不高的「有界上下文」可以使用简单的架构
* 花了过多的精力和时间在把「战术模式」的实现得更完美上面了；而事实上，这些模式只是参考，不是规则，必须了解什么时候可以不完全按这些「模式」来实施；明白这些「模式」能解决什么问题，比掌握怎么用代码实现这些「模式」更重要
* 在使用了 DDD 的「简化版」的同时，又忽略了 DDD 的原则，只是把精力主要放在编码上。没有用到「协作」，「知识提取」，「领域模型」设计，提取 UL 等「战略模式」
* 忽略了 DDD 真正的价值所在：「协作」，「沟通」，「上下文」
* 低估了划分「上下文」的重要性，从而导致应用软件成为一个「大泥球」
* UL 定义得不完善，从而导致了歧义和误解：「沟通」是解决「问题域」的基础，UL 不完善的话，就不能好的解决问题
* 缺乏「协作」和「沟通」，从而实现的方案过于技术化，并不能真正的解决问题（为了技术而技术）
  * 「沟通」不充分，往往会造成对「问题域」一些潜在「领域逻辑」的忽视
* 不能接受不完美；事实上，要把「核心子域」划分出来，并把精力集中投入到「核心子域」上
* 把一些「简单问题」复杂化了：
  * 简单，或者不重要的「子域」其实不需要实施 DDD 原则；也没有必要对所有的「有界上下文」使用「模型驱动设计」模式
  * 不敢使用 CRUD 模式；在合适的场合，使用 CRUD 模式其实是简单而有效的
  * 总之，在引入复杂之前，先评估一下付出的代价是否能匹配获得的好处
* 低估了实施 DDD 的成本。事实上，实施 DDD 的要求是相当高的：
  * 对整个团队有非常高的要求
  * 领域专家要愿意投入大量精力，并愿意协同工作
  * 需要持续迭代对设计进行打磨
  * 对简单问题使用 DDD 反而可能拖慢整体的进度

## DDD 的实施

> 首先强调一点：不是无脑推广使用 DDD；而是在了解 DDD 的适用场景和 DDD 的优势后，再判断是否要使用 DDD
>
> 也要强调开发团队的学习；特别是对 DDD「战略模式」的学习和使用
>
> 同时，相对于向「甲方」推销 DDD 的概念，更重要的是，找到「业务专家」和他们随时随地的协同工作

DDD 的实施过程：

* 「产品愿景」阶段：先要通过和「甲方」沟通，搞清楚「产品愿景」。可以通过一些问题来达到这一目标：
  * 产品的业务目标（或者说，业务驱动力）是什么？
  * 产品能给业务带来什么价值？
  * 怎么确定这个产品一定能成功？如果成功的话，产品看起来会是什么样子？
  * 和现存的类似产品有什么本质不同？
* 「需求收集」阶段：在找「甲方」收集需求的时候，可以使用 BDD
  * 最后收集到的是 User-Cases、Input、Output
  * 收集需求的过程中，也会形成 UL
  * 「需求收集」阶段只专注于「问题域」，并不急于投入到「解决域」
  * 如果需求过于庞大，可以考虑对「问题空间」进行提炼，也就是把问题抽象到更高的层次，并新建「子域」，然后再识别出「核心域」，「通用域」，「支撑域」
  * 把主要精力投入到「核心域」；尽量把「核心域」做得小而美
* 「边界划分」阶段：在「解空间」进行建模之前，先要划分出「有界上下文」，并建立 Context Map
  * 在「建模」之前，要先搞清楚系统的大环境的状况，当前产品在整个体系中如何存在
  * 要识别出各个「有界上下文」，以及各个「上下文」和当前产品如何相互作用，也就是要建立「上下文映射」（Context Map）
  * 「边界划分」（建立 Context Map）具体工作包括：
    * 在「问题域」上，确认本团队负责的「模型」
    * 画出各个「上下文」、对各个「上下文」命名、标明各个「上下文」的负责人
    * 确认「上下文映射」映射时的各个「集成点」
    * 确认「上下文映射」映射时需要交互的数据
    * 标明「上下文」之间的相互关系的种类（梳理上下游）
    * 持续收集当前产品所处的整个体系大环境的信息
  * 另外，Context Map 就是「作战地图」；不需要太复杂，只要能快速准确的表达出映射关系就行了
* 「建模阶段」：建模时要牢记 DDD 的原则，只有在合适的场景才使用 DDD，否则就是浪费资源。建模时的一些建议：
  * 「问题域」的不同部分有不同的重要性，只是对重要的部分实施 DDD。要选择好自己的主战场
  * 和「领域专家」一起协作，进行「建模」
  * 「建模」工作的粒度是选择一个「行为」，并围绕着该行为具体的场景；而不是对整个「问题域」进行建模
    * 所谓的「行为」就是：Given-When-Then
  * 「建模」工作要从最重要，最有价值的场景开始，而不是从最容易「建模」的场景开始；先要去解决整个「系统」最核心的部分
  * 在「建模」阶段要持续对 UL 进行迭代。尽管 UL 是在「需求收集」阶段创建的，但需要持续迭代，消除歧义；当然，UL 进化的同时，代码也要同时迭代，保持和 UL 的一致
  * 弃掉前 2 个模型；前 2 个模型往往都是在对「问题域」理解不够深刻时产出的，弃掉并不可惜
  * 「模型」产出后，就是着手通过代码来实现该「模型」；但如果在实现过程中，发现「模型」不准确的话，需要反过来修订「模型」。总之，「模型」和「代码」要不断迭代，一起进化
  * 「领域模型」建立以后要能在具体的业务场景中作为例子来验证。「领域模型」需遵守 2 原则：
    * Be relevant：Able to answer questions in the problem domain and enforce rules and invariants
    * Be expressive：Able to communicate to developers exactly why it’s doing what it’s doing
  * 保持「模型」专注于单个问题，同时其代码实现也就应该是简单的（一旦发现代码陷入复杂就需要引起警惕）
  * 如果存在「遗留代码」，不要把精力投入到「遗留代码」；而是给「遗留代码」划分一个清晰的边界，保护「遗留代码」不会影响到其他部分
  * 尽早的做集成，持续的做集成。通过集成，可以尽早不断的对「模型」进行检验
  * 「非技术性重构」：不是在技术层面做重构，而是通过对「领域」更深层次的认识，更新「领域知识」，对「模型」进行迭代，再实施对应的代码重构
  * 当「模型」变得更庞大时，要考虑对「解空间」进行分解。相对于对代码精雕细琢，更值得去追求完美的边界划分
  * 「建模」也是不断迭代，核心模型至少需要制作出 3 个版本才能最后达到目标。所以，代码实现也需要相应的比较灵活，要能适应「模型」的持续迭代
  * 「建模」过程中要注意把深层次的「隐式规则」发掘出来，更新到「领域模型」中，并明确的实现在代码中，消除歧义
  * 注意给新的概念命名，随时更新 UL

## 集成有界上下文

从本节开始详细介绍 DDD 的「战略模式」（strategic pattern）。

在识别出「有界上下文」以后，就可以开始集成它们，以便实现完整的 User Cases。

说白了，集成好了以后，就是一个分布式系统。所以，实现上最大的挑战就是如何实现一个可靠的分布式系统（包括技术上的挑战，以及组织上的挑战），下面重点就会针对这些内容来介绍。

在实现分布式系统时，可以考虑使用 SOA 模式。另外，细节上也可以考虑使用响应式的事件驱动编程。

实现分布式系统时，对 SLA 的定义也是必要的。

### 如何集成有界上下文

先要确定软件服务之间应该采用哪种通讯方式。

代码实现上，要注意保持「有界上下文」之间的「松耦合」。

要注意使用 SRP 原则：不同的「有界上下文」专注各自的职责。

可以把所有「上下文」的代码放在同个代码库中；也把不同的「上下文」的代码放在不同的代码库中。哪种好就用哪种，没有强制的规定。但使用单代码库时，需要考虑可能的一些问题：

* 如果不同的「上下文」的代码在同个代码库中，需要避免修改一个「上下文」代码的时候，无意动到其他「上下文」的代码
* 尽量避免使用「数据库集成」模式。使用「数据库集成」会使得各个「上下文」紧密的耦合在一起
* 不同「上下文」代码都在同个代码库中还会有一个问题：可能需要开多个分支并行工作，各个分支间的协调管理比较麻烦。发布上也不好协调，持续集成变得难以实施
* 要注意维护「上下文」的边界，这比代码的美观更重要（必要时可能需要把相似的代码复制到不同的「上下文」）

在处理「遗留系统」时，可以采用一些常用的模式：

* Bubble Context 模式：新的代码被隔离在「气泡上下文」中，不直接和「遗留系统」接触。对应的，也需要给「遗留系统」创建一个 ACL 层（防腐层），ACL 层用于对「气泡」中的模型和「遗留系统」做双向翻译
* Autonomous Bubble Context 模式：技术上实现一个更加「独立自主」的「气泡上下文」。这种「气泡上下文」往往采用「异步」的方式来和「遗留系统」进行通讯，当时，实现上也会更加复杂
* Exposing Legacy Systems as Services 模式：把「遗留系统」封装成服务暴露出来。当多个「上下文」都需要使用同一个「遗留系统」时，封装成服务暴露出来可能更加有效；但实现上要考量的方面也比较多

### 集成分布式有界上下文

常用的分布式「上下文」的集成方式是 RPC，不过「纯文件共享」和「数据库集成」在有时候也适用。

总之，要从「可扩展性」、「可用性」、「可靠性」（这里的「可靠性」指的是系统如何容错）等方面来考量如何进行集成。当然，如何选择也要综合考量「业务需求」和「成本」等因素。

「纯文件共享」和「数据库集成」可以在简单的系统中使用，但当系统变得更加复杂时就不再适用了。RPC（或 REST）才是王道。但使用 RPC 时也要注意一些问题：

* 要考虑网络不可用等错误出现时的容错方案（技术上或业务上的容错）
* 使用 RPC 时，上下游系统的耦合是比较紧密的
* 分布式系统中，必须关注如何合理处理「分布式事务」（能忍受不一致，或者能实现「最终一致」就够了）

响应式消息驱动也是一种选择。不过由于是新技术，实现上要付出的代价可能会更高一点。

### SOA 架构

可以考虑使用 SOA 架构（或者说是「微服务架构」）结合「响应式编程」来实现集成的松耦合：

* 相对于「响应式编程」是在低层次上（代码上）实现「松耦合」的目的；SOA 是在高层次上（业务上）实现「松耦合」
* 考虑把「有界上下文」看成是 SOA 服务，这样「有界上下文」就有可能被分解为「业务组件」
  * 把「有界上下文」所承担的每个「职责」封装成一个个的「业务组件」
  * 而各个「业务组件」是相互松耦合的（无 RPC 调用，无数据库共享），便于维护
  * 「业务组件」进一步分解为「组件」：「业务组件」需要处理各种「业务消息」，可以使用不同的「微服务」（或者「组件」）来处理不同的「业务消息」（利用响应式编程来处理消息）
  * 以「微服务」（或者「组件」）作为部署单元，这样可以优化对硬件的使用率。而「微服务」（或者「组件」）之间通讯比较灵活，可以采用数据库共享的方式来通讯

总结：

> SOA 架构是把「有界上下文」分解为「业务组件」；「业务组件」又分解为「微服务」

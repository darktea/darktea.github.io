---
title: DDD Notes
date: 2022-10-07 00:00:00 +0800
categories: [notes]
tags: [DDD]
---

## DDD 总览

在深入 DDD 细节之前，先从高的视角来简要介绍一下 DDD 的基本思想。

* Problem Space：进入 DDD 的第一步就是先定义「问题空间」
  * 也就是先把精力集中在「问题域」（Problem Domain）上
* Solution Space：一旦理解了「问题域」，就可以使用 DDD 的「战略模式」实现「解决方案」
  * 「战略模式」能使得产品的「核心部分」和「通用区域」分割开了，避免修改「核心部分」时影响到整个产品
  * 产品的「核心部分」（极其复杂+频繁变动）必须是基于「模型」的。DDD 的「战术模式」帮助开发人员针对 Domain，创建出代码级别的「模型」。总之：
    * 「模型」是分离复杂性，让「软件」能够持续进化的关键
    * 「模型」也是在「问题域」上和其他开发人员以及领域专家沟通的关键

所以我们准备分 3 部分来介绍 DDD：

* DDD 基础哲学，以及 DDD 的原则与实践
* DDD 的「战略模式」（strategic pattern）
* DDD 的「战术模式」（tactical pattern）

## DDD 原则与实践

### 复杂问题域的挑战

进入 DDD 之前，先说明一下存在的问题：

* 反模式：「大泥球」模式。领域复杂性和技术复杂性被混合在一起，导致了软件维护困难

* 「通用语言」和「问题域知识」的缺乏使得软件不能和商业逻辑对应，导致了「大泥球」模式。也使得「分析模式」和「代码」之间转换的代价极其高昂
  * 「分析模式」是一种表现形式，使得非技术人员能够理解软件的构成
* 如果不围绕着「问题域」来设计和和组织软件的开发，会导致复杂度快速提升

> 什么是「问题域」？
>
> 「问题域」指的是当前正在构建的软件的主题。DDD 强调的是在构建大型复杂软件时，必须把对领域的关注放在最高的位置。
>
> 例如，在构架一个医疗相关的软件时，不是要去了解怎么成为一个医生，而是要专注于该领域的术语，不同的相关方看待病人的不同方式，以及医生需要收集哪些信息，并且怎么处理这些信息。

### DDD 解决复杂问题域的模式

* DDD 的「战略模式」：The strategic patterns of DDD distill the **problem domain** and shape the architecture of an application
  * 识别出「核心域」，找到软件真正的价值所在，「核心域」才是真正值得投资的部分。避免「大泥球」模式的出现
  * 在「解空间」中，为每个「子领域」（subdomain）构建一个「软件模型」来和「业务逻辑」对齐。不过由于不同的「子领域」的重要性及复杂度不同，所付出的实现代价也就不同（例如，不复杂的子领域，甚至可以不用面向对象模型来构建）
  * 既然「模型」是由「领域专家」和「开发人员」合作建立起来的，所以一套不断进化的「通用语言」（UL）是必须的。「分析模型」中的新概念会通过 UI 反馈到「代码」中，「代码」中的概念也会被复制到 UI 中
  * 「模型」属于「界限上下文」（Bounded Context），「界限上下文」定义了「模型」的应用范围，同时确保了「模型」的完整性。这种围绕着模型的保护边界可以防止软件变成「大泥球」模式（「模型」被隔离在自己的边界内变化，避免把复杂度扩展到其他上线文）
  * Context Map 用来表现处于不同「上下文」中的「模型」的关系
* DDD 的「战术模式」：其实就是一系列的「模式」，这些「模式」用来帮助开发人员更有效的创建「边界上下文」中的「模型」（很多时候是针对代码层面）
  * 这些「模式」从细节上关注如何来管理「问题空间」的复杂度和「解空间」的复杂度
  * 「问题空间」：把「问题域」提炼成可管理的「子域」；并识别出各个「子域」的重要性
  * 「解空间」：包含了各种「模式」，这些「模式」用于塑造软件的「架构」，使得「软件」更容易的被管理

### DDD 的原则与实践

原则：

* 集中在「核心域」（Core SubDomain）
* 协作：需要「领域专家」和「开发人员」的协作，以及相互学习
* 通过探索和试验来创建「模型」：「分析模型」和「代码模型」的不断迭代和相互反馈
* 交流：必须创建 UI 来保障正确而高效的交流
* 理解「模型」的应用范围（「模型」处于「上下文边界」内）
* 「模型」保持不断进化

### DDD 的常见误区

误区：

* 「战术模式」是 DDD 的关键
* DDD 是一种 Framework
* DDD 是银弹

## 对问题域进行提取

* 从「问题域」提取出用于「模型」建设的知识
  * 知识提取必须和「业务专家」合作才能成功：「业务专家」+「开发团队」+「Use Cases」=> 满足用例的「模型」
  * 「领域知识」可能比技术本身还要重要：开发人员需要有使用简单术语向客户描绘「业务域」中复杂概念的能力
* 完成「知识提取」并达成共识的一个标志是产出 UI（通用语言）
* 「利益方」和「业务专家」是不同的角色
  * 「利益方」更多的是描绘对系统的愿景、系统的输入输出；「开发团队」把这些信息收集起来形成「Use Cases」
  * 「业务专家」和「开发团队」一起合作进行「知识提取」，并产出「模型」
* 一些有用的手段：
  * 「手绘的草图」
  * CRC 卡（类职责合作卡）：类名及其蕴含的概念+类的职责+类之间的合作关系
  * 避免过早的对模型中的概念命名
  * 在和「业务专家」交流时可以使用 BDD（GWT，Given-When-Then）。也就是对一个特性进行描绘可以分解为：条件（Given）、场景中包含的事件（When）、输出结果（Then）
  * 利用快速原型
  * Impact Mapping（理解为业务事件「影响力」）：利用业务事件的「影响力」来更好的理解业务
    * 例如：利用「思维导图」的形式展示出「提高自行车销量 25%」这个业务事件的影响力
  * 业务模型图
  * ......

## Model Driven Design

### Domain Model

* Domain Model（领域模型） 是「解空间」的概念；对应的，Domain （领域）是「问题空间」的概念
  * 「代码模型」是「领域模型」的主要表现形式
* DDD 强调「代码模型」（也就是实现）需要和「分析模型」（也就是设计）保持一致，这种一致需要靠 UI（通用语言）来保证
  * 「分析模型」也叫做「业务模型」。「分析模型」用于对「问题域」的理解
  * 如果「开发团队」发现代码和「分析模式」存在不一致，需要立即和「领域专家」沟通解决：code is model；code is truth
  * 「模型驱动设计」和 DDD（领域驱动设计）的区别就是前者注重实现，后者注重语言、协作和知识

### 通用语言

* 「通用语言」是 DDD 的基础（既然 DDD 强调「业务专家」和「开发团队」直接的沟通和协作）
* 从「实际例子」中来提取 UI。但注意：
  * 不要在描述「实际例子」时使用「技术术语」
  * 不要在描述「实际例子」时转到「解空间」，而是要专注在「问题空间」
  * 尽量避免使用「过载」的词语，例如：service，manager，policy 等等
  * 专注于「核心域」，首先在「核心域」使用「模型驱动」并建立 UI；不需要把太多精力放到「通用域」和「支撑域」

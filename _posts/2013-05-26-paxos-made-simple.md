---
layout: post
title: Paxos Made Simple 论文 Notes
category: notes
---

# 一, Paxos 算法是用来解决什么问题的?

先看一个场景: 一个日志收集系统, 需要从多个不同的机器上实时收集日志.

最简单的实现方式是, 找一台中心服务器, 所有的日志生产机器作为客户端, 不断的把日志提交到中心服务器, 中心服务器实现日志收集的目的.

但这种实现方式有一个问题, 中心服务器是一个单点, 一旦中心服务器发生故障, 整个系统不可用.

改进方案: 找多个服务器来收集日志, 例如 2 个. 当每台日志生产机器需要提交日志时, 每条日志都同时被提交到两台收集日志的服务器上面.
这样, 同时有多个日志收集服务器在工作, 解决了单点问题.

但这种多收集服务器的实现方式有另外一个问题, 两台收集日志服务器上收集到的日志可能会不一致. 
例如, 假设有两台日志生产机器 P1, P2; 同时有两台日志收集机器: Q1, Q2. 考虑下面这种情况:

1. P1 发送一条日志信息 M1 分别到 Q1, Q2
2. P2 发送一条日志信息 M2 分别到 Q1, Q2

但由于实际网络的状况, 日志被收集到的顺序在 Q1, Q2 可能会不一致, 例如: 

* Q1 收集到的日志的顺序是 M1, M2
* 而 Q2 收集到的日志的顺序是 M2, M1

上面的请求只是一种不一致的情况, 现实环境中, 情况更加复杂, 可能会有更多的问题 (例如, 由于网络不稳定, P1 发出的消息 M1 到达了 Q1, 但 M1 没有到达 Q2, 丢失了)

上面这种情况是一个典型的分布式系统的一致性 (consensus) 问题:

* 在一个分布式系统中, 有一些 processes, 每个 process 都可以提出一个 value.
* consensus 算法就是用来从这些 values 里选定一个最终 value. 
* 如果没有 value 被提出来, 那么就没有 value 被选中
* 如果某个 value 被选中, 那么所有的 processes 都应该被学习到

有很多分布式一致性算法来解决这种问题. 

而 **Paxos 算法就是一种分布式一致性算法, 同时 Paxos 还具有容错性, 能在各种错误环境中, 保证一致性**

# 二, Paxos 算法的系统模型

算法中有三种角色:

* 提议者 (proposers): 提议者提出提案
* 决策者 (acceptors): 决策者负责批准提案
* 学习者 (learners): 一旦某个提案被多数派决策者批准, 那么就形成了一个决议. 当决议形成以后, 学习者负责学习决议 (我的理解是学习者获取到这个决议, 并以某种形式把决议持久化)

在具体实现中, 某个 process 可以扮演多个角色.

这里还有一个 **多数派** 的概念: acceptors 数量为 n，超过 (n+1)/2 的 acceptors 的集合就是一个多数派.

节点之间通过发送消息进行通信, 通信方式采用异步, 非拜占庭模型, 该模型中:

* process 以任意的速度进行操作, 可能因为故障而停止, 也可以重新启动. 并且节点所选择的值不会因为重启等故障而丢失
* 消息可以延迟发送, 多次发送或丢失, 但不会被篡改 (即不存在拜占庭问题)

一般来说, 分布式算法都需要满足 Safety 和 Liveness.

Paxos 算法的系统模型中, 

Safety:

* 最后形成的决议必须是之前被提议者提出的提案
* 算法的每次执行, 最后只能形成一个决议 (这个最重要, 如果不满足这个, 那么会形成多个决议, 就出现不一致了)
* 只有形成决议以后才能被学习者学习 (在形成决议之前, 提案是不能被学习的)

Liveness:

* 只要有提案被提出, 保证最终有一个提案会被选出来做为决议
* 决议形成以后, 学习者最后能学习到决议

{% include references.md %}

https://github.com/dsdoc/dsdoc/blob/master/paxosmadesimple/index.rst
http://www.vpsee.com/2009/09/paxos-algorithm/
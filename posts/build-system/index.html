<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Build Systems" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="一. CMake" /><meta property="og:description" content="一. CMake" /><link rel="canonical" href="https://darktea.github.io/posts/build-system/" /><meta property="og:url" content="https://darktea.github.io/posts/build-system/" /><meta property="og:site_name" content="Darktea" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-06T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Build Systems" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-09T19:45:20+08:00","datePublished":"2022-05-06T00:00:00+08:00","description":"一. CMake","headline":"Build Systems","mainEntityOfPage":{"@type":"WebPage","@id":"https://darktea.github.io/posts/build-system/"},"url":"https://darktea.github.io/posts/build-system/"}</script><title>Build Systems | Darktea</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Darktea"><meta name="application-name" content="Darktea"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/android-chrome-512x512.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Darktea</a></div><div class="site-subtitle font-italic">Know nothing</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/darktea" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tiantianding','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Build Systems</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Build Systems</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/darktea">darktea</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1651766400" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-05-06 </em> </span> <span> 更新于 <em class="timeago" data-ts="1712663120" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-04-09 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="5953 字"> <em>33 分钟</em>阅读</span></div></div></div><div class="post-content"><h2 id="一-cmake"><span class="mr-2">一. CMake</span><a href="#一-cmake" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="1-modern-cmake"><span class="mr-2">1. Modern CMake</span><a href="#1-modern-cmake" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>Modern CMake</strong>: 围绕着 targets 来管理应用的构建。同时，要成功构建 target，也需要配置 target 对应的 properties。</p><ul><li><strong>Target</strong>：target 就是被构建应用的各个组件的抽象。一个可执行文件是一个 target，一个库是一个 target<ul><li>构建一个应用就是构建一系列 targets 的集合。而且这些 targets 可能互相依赖</ul><li><strong>Property</strong>：需要对被构建的 target 配置 properties，才能成功进行构建：<ul><li>target 是从哪些 source files 构建而来的<li>target 构建时的编译选项<li>target 需要链接哪些库</ul></ul><p>总之，<strong>Modern CMake</strong> 的目的就是创建一系列的 targets，同时定义这些 targets 必要的 properties。</p><h3 id="2-properties-scopes"><span class="mr-2">2. Properties Scopes</span><a href="#2-properties-scopes" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p><strong>Target properties</strong> 可以被定义在 2 种 scopes 中：<strong>INTERFACE</strong> and <strong>PRIVATE</strong>：</p><ul><li><strong>INTERFACE</strong>：暴露给使用该 target 的用户使用的 properties<li><strong>PRIVATE</strong>：只是在内部构建该 target 时使用的 properties</ul><p>另外，如果一个 property 同时是 <strong>INTERFACE</strong> 和 <strong>PRIVATE</strong> 的，那么这个 property 为 <strong>PUBLIC</strong>。</p><p>同时，<strong>INTERFACE</strong> property 会被透传给 target 的使用者；相反的，<strong>PRIVATE</strong> 的 property 不会被透传给 target 的使用者。</p><h3 id="3-cmake-的职责"><span class="mr-2">3. CMake 的职责</span><a href="#3-cmake-的职责" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>管理 C/C++ 应用。其中包括对从构建到发布整个生命周期中的各个步骤进行管理：</p><ul><li>Compiling executables and libraries<li>Managing dependencies<li>Testing<li>Installing<li>Packaging<li>Producing documentation<li>Testing some more</ul><p>用户需要利用「CMake 脚本」来实现对应用的管理。内容为「CMake 脚本」的文件叫 <strong>listfile</strong>：</p><ul><li>CMakeLists.txt：在项目的顶层目录下，cmake 执行时从这个文件开始执行<li>以 cmake 为文件后缀的文件</ul><h3 id="4-最佳实践"><span class="mr-2">4. 最佳实践</span><a href="#4-最佳实践" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>把一个大的 Project 进行拆分；而且是拆分成不同的目录，每个目录为项目的一个组成部分。例如：<ul><li>代码、测试、文档、外部依赖，脚本等<li>而每一个组成部分又可以进行进一步拆分，代码目录可以再拆分成库代码，执行程序代码等等</ul></ul><blockquote><p>可以使用 CMake 提供的 <strong>add_subdirectory</strong> 命令实现项目的拆分</p></blockquote><ul><li>CMake 提供了一个 <strong>Unit Test 规范（CTest）</strong>，只要按照 CTest 规范进行配置，可以集成各种 Unit Test 框架。从而实现 Unit Test 的自动化运行<ul><li>推荐使用 GTest 框架，能够和 CMake 有很好的配合<li>C 语言的话，我现在使用 <a href="https://github.com/jasmcaus/tau">Tau</a></ul></ul><h3 id="5-更多细节"><span class="mr-2">5. 更多细节</span><a href="#5-更多细节" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>我们给出了一个 CMake 项目的常用结构，可以直接参考（其中的 CMakeLists.txt 中有详细的注释说明）：</p><p><a href="https://github.com/darktea/cmake-full-project">https://github.com/darktea/cmake-full-project</a></p><p>更多细节备忘：</p><ul><li>CMake 中可以使用 list；同时提供了 <strong>list 命令</strong>来操控 list。例如：</ul><div class="language-cmake highlighter-rouge"><div class="code-header"> <span data-label-text="Cmake"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1"># 把 "${CMAKE_SOURCE_DIR}/cmake" 添加（append）到 CMAKE_MODULE_PATH 路径中去</span>
<span class="c1"># 其中：</span>
<span class="c1"># CMAKE_SOURCE_DIR 是当前项目的顶级目录</span>
<span class="c1"># CMAKE_MODULE_PATH 是 cmake module（cmake 模块）所在的目录</span>
<span class="nb">list</span><span class="p">(</span>APPEND CMAKE_MODULE_PATH <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_SOURCE_DIR</span><span class="si">}</span><span class="s2">/cmake"</span><span class="p">)</span>
</pre></table></code></div></div><ul><li>CMake 的变量（variable）的作用域（scope）比较复杂；分为 2 种作用域：<ul><li>Function Scope<li>Directory Scope</ul></ul><p>我们这里只简单的通过一个例子简单说明一下 Function 作用域：</p><div class="language-cmake highlighter-rouge"><div class="code-header"> <span data-label-text="Cmake"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.20.0<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>Scope<span class="p">)</span>

<span class="nb">function</span><span class="p">(</span>Inner<span class="p">)</span>
<span class="c1"># 进入 inner 函数后，变量 V 的值还是上一层函数的值 2</span>
  <span class="nb">message</span><span class="p">(</span><span class="s2">"  &gt; Inner: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># 在函数中使用 set 命令会把 V 的值改为 3</span>
  <span class="nb">set</span><span class="p">(</span>V 3<span class="p">)</span>
<span class="c1"># V 的当前值为 3</span>
  <span class="nb">message</span><span class="p">(</span><span class="s2">"  &lt; Inner: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="nb">function</span><span class="p">(</span>Outer<span class="p">)</span>
<span class="c1"># 进入函数后，全局变量 V 的值不变，还是 1</span>
  <span class="nb">message</span><span class="p">(</span><span class="s2">" &gt; Outer: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># 在函数中使用 set 命令会把 V 的值改为 2</span>
  <span class="nb">set</span><span class="p">(</span>V 2<span class="p">)</span>
<span class="c1"># 调用下一级函数 inner</span>
  <span class="nf">Inner</span><span class="p">()</span>
<span class="c1"># 从 inner 函数返回以后，V 的值恢复到 2</span>
  <span class="nb">message</span><span class="p">(</span><span class="s2">" &lt; Outer: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>

<span class="c1"># 设置全局变量 V 的值为 1</span>
<span class="nb">set</span><span class="p">(</span>V 1<span class="p">)</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">"&gt; Global: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="c1"># 调用函数 Outer</span>
<span class="nf">Outer</span><span class="p">()</span>

<span class="c1"># 从函数 Outer 返回后，V 的值恢复到 1</span>
<span class="nb">message</span><span class="p">(</span><span class="s2">"&lt; Global: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
</pre></table></code></div></div><p>运行这个例子可以得到结果：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;</span> Global: 1
 <span class="o">&gt;</span> Outer: 1
  <span class="o">&gt;</span> Inner: 2
  &lt; Inner: 3
 &lt; Outer: 2
&lt; Global: 1
</pre></table></code></div></div><p>另外，如果上面例子的 inner 函数改为：</p><div class="language-cmake highlighter-rouge"><div class="code-header"> <span data-label-text="Cmake"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nb">function</span><span class="p">(</span>Inner<span class="p">)</span>
  <span class="nb">message</span><span class="p">(</span><span class="s2">"  &gt; Inner: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="c1"># 使用 PARENT_SCOPE 修改上一层函数中 V 的值；</span>
<span class="c1"># 但不会修改本函数和全局的 V 的值</span>
  <span class="nb">set</span><span class="p">(</span>V 3 PARENT_SCOPE<span class="p">)</span>
  <span class="nb">message</span><span class="p">(</span><span class="s2">"  &lt; Inner: </span><span class="si">${</span><span class="nv">V</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
<span class="nb">endfunction</span><span class="p">()</span>
</pre></table></code></div></div><p>运行结果如下（Outer 函数的打印为 Out: 3）：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="o">&gt;</span> Global: 1
 <span class="o">&gt;</span> Outer: 1
  <span class="o">&gt;</span> Inner: 2
  &lt; Inner: 2
 &lt; Outer: 3
&lt; Global: 1
</pre></table></code></div></div><h3 id="6-reference"><span class="mr-2">6. Reference</span><a href="#6-reference" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><a href="https://kubasejdak.com/modern-cmake-is-like-inheritance">Modern CMake is like inheritance</a></ul><h2 id="二-c-语言相关"><span class="mr-2">二. C 语言相关</span><a href="#二-c-语言相关" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="概念"><span class="mr-2">概念</span><a href="#概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="value"><span class="mr-2">Value</span><a href="#value" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>从「可移植」方面来考量的话，就 C 语言中的数据来说，作为一个 programmer，应该尽可能的只关注 <a href="#value">value</a> 本身，而不是 <a href="#value">value</a> 的具体 <strong>representation</strong><ul><li>C programs primarily reason about <a href="#value">value</a> and <strong>NOT</strong> about their <strong>representation</strong>.<li>这个道理就类似现实世界中，同一个数在不同的语言（例如用罗马数字来表示数字）中有不同的表达方式，但我们关注的是数本身，而不是表达方式</ul><li>C 中，<a href="#value">value</a> 是抽象实体，抽象于特定的实现，和特定的运行之上<li><a href="#value">value</a> 和 representation 之前的相互转换是编译器应该关注的事情<li>C 程序可以抽象成「有序抽象状态机」。「抽象状态机」的运行理想上是和平台无关的，「状态机」中和平台无关的相关概念包括 <a href="#value">value</a>、object、<a href="#type">type</a>：<ul><li>所谓「有序抽象状态机」就是用来操作 <a href="#value">value</a>（在给定时刻，程序的变量，variable，拥有特定的 <a href="#value">value</a>）<li><strong><a href="#value">value</a></strong>：就是「值」的抽象概念，和具体的程序是无关的；而且 C 中的 <a href="#value">value</a> 都是「数值」（或者可以被转换为「数值」）</ul></ul><p>「状态机」状态的转换由 3 者决定： <a href="#value">value</a>、<a href="#type">type</a>、<a href="#binary-representation">Binary Representation</a></p><h4 id="type"><span class="mr-2">Type</span><a href="#type" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><p><a href="#type">type</a>：C 语言中，<a href="#type">type</a> 是 <a href="#value">value</a> 的属性</p><ul><li>所有的 <a href="#value">value</a> 的 <a href="#type">type</a> 都静态的决定（非运行时决定）；所谓的「静态类型」<li>在一个 <a href="#value">value</a> 上可以执行什么操作，由 <a href="#value">value</a> 的 <a href="#type">type</a> 决定<li><a href="#value">value</a> 上操作的结果是什么会被 <a href="#type">type</a> 决定（但也不能完全被 <a href="#type">type</a> 决定，结果也受 <a href="#binary-representation">Binary Representation</a> 的影响）<li>编译器是否能做一些优化，也受到 <a href="#type">type</a> 的影响（例如，对 unsigned int 上的操作做优化时，可以不考虑 overflow）</ul></ul><h4 id="object"><span class="mr-2">Object</span><a href="#object" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>澄清几个概念：</p><ul><li><strong><a href="#object">object</a></strong>：可以被看成一种 box 本身<li><strong>identifier</strong>：用来标识 box 的 name<li><strong><a href="#type">type</a></strong>：如果 <a href="#object">object</a> 看成是 box 的话，那么 <a href="#type">type</a> 就是 box 的 specification<li><strong><a href="#value">value</a></strong>：如果 <a href="#object">object</a> 看成 box 的话，<a href="#value">value</a> 就是放在 box 中的 content</ul><blockquote><p>赋值语句可以理解为：把 value 赋值给 object（把 content 放进 box）</p><p>C 语言中，可能是不需要引入「左值」、「右值」的概念；没有那么复杂，直接用 object、value 的概念就行了。</p><p>为什么？请参考下面的讨论……</p></blockquote><p>C 语言里面的「左右值」的讨论：</p><ul><li>先不考虑 function 的场景，C 语言中的 lvalue 中的 “l” 代表的意思不是「左」的意思，是「地址可被定位」的意思：<ul><li>lvalue simply means an <a href="#object">object</a> that has an identifiable <strong>location</strong> in memory<li>「左值」就是 <a href="#object">object</a><li>所谓「右值」，在 C 语言中，其实是「非左值」</ul></ul><p>一个 C 语言中「非左值」的例子：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span> <span class="n">S</span><span class="p">;</span>

<span class="n">S</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">S</span> <span class="n">s</span><span class="p">;</span>
  <span class="n">s</span><span class="p">.</span><span class="n">i</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">S</span> <span class="n">s</span><span class="p">;</span>      <span class="c1">// 这里的 s 是「左值」</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>  <span class="c1">// 这里的 f() 就是一个「非左值」</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="binary-representation"><span class="mr-2">Binary Representation</span><a href="#binary-representation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><a href="#binary-representation">Binary Representation</a>：<a href="#type">type</a> 的二进制表示。例如对一个 16 位的 unsigned int，其二进制表示就很简单：直接用 16 位 bits（b<sub>0</sub>, b<sub>1</sub>…b<sub>15</sub>）表示就行了。一般来说是具体平台无关，也是一种可抽象的概念<ul><li>但由于各种平台的差异，C 的标准并不能完全控制所有的具体实现细节；也就是说，即使遵循了 C 标准，也不能完全保证同样的操作在所有平台上的结果完全一致。<li><a href="#binary-representation">Binary Representation</a> 也会对在 <a href="#value">value</a> 上的操作的结果造成影响<li>但这里的 <a href="#binary-representation">Binary Representation</a> 还是一个抽象的概念，并没有决定 <a href="#value">value</a> 物理上具体怎么存储的。<a href="#value">value</a> 物理上怎么存储的是 <a href="#object-representation">Object Representation</a> 相关的概念</ul></ul><p>举个例子：</p><blockquote><p>C 标准说明了 <code class="language-plaintext highlighter-rouge">size_t</code> 这个 <a href="#type">type</a> 是一个大于 0 的整数，据此可以推演出 <code class="language-plaintext highlighter-rouge">size_t</code> 这个 <a href="#type">type</a> 的各种操作；但同时，由于在不同的平台上，<code class="language-plaintext highlighter-rouge">size_t</code> 的 <code class="language-plaintext highlighter-rouge">SIZE_MAX</code> 并不一样，所以在 <code class="language-plaintext highlighter-rouge">size_t</code> 上的操作结果也是和平台相关的，并不能仅仅由 <a href="#type">type</a> 就决定其操作结果；和平台相关的部分需要由 <a href="#binary-representation">Binary Representation</a> 来决定。</p></blockquote><p>总之：</p><blockquote><p>「抽象状态机」状态的转换由 3 者决定： <a href="#value">value</a>、<a href="#type">type</a>、<a href="#binary-representation">Binary Representation</a></p></blockquote><p>其他一些 tips：</p><ul><li>尽量使用 unsigned 类型，避免可能的 UB 行为<li>尽量使用 uint8_t, uint16_t, uint32_t……</ul><h4 id="object-representation"><span class="mr-2">Object Representation</span><a href="#object-representation" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li><a href="#object-representation">Object Representation</a> 是和平台相关的概念，不是抽象的，具体由编译器来决定</ul><p>总之，</p><blockquote><p>「抽象状态机」状态的迁移只由 3 者决定：<a href="#value">value</a>，<a href="#type">type</a>，<a href="#object-representation">Object Representation</a></p></blockquote><h3 id="derived-data-types"><span class="mr-2">Derived data types</span><a href="#derived-data-types" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>4 种非基本类型：</p><ul><li>2 种组合类型<ul><li>Array<li>Structure</ul><li>2 种非组合类型<ul><li>Pointer<li>Union</ul></ul><h4 id="array"><span class="mr-2">Array</span><a href="#array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Array 作为函数参数时，数组的长度信息会<strong>丢失</strong>，但可以使用 <code class="language-plaintext highlighter-rouge">static</code> 关键字进行说明。例如：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// static 2 表示作为函数入参的数组的程度「大于等于」 2</span>
<span class="kt">void</span> <span class="nf">swap_double</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="k">static</span> <span class="mi">2</span><span class="p">])</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">void func(double a[static 7]);</code> 中的 <code class="language-plaintext highlighter-rouge">static 7</code> 标明 func 的参数是一个至少包含 7 个元素的数组（或指针）<li>「字符串」是最后一个元素为 0 的 char 数组。下面分别给出 2 类例子，第一类是「字符串」，第二类不是「字符串」：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// 下面 4 个是字符串（最后一个元素为 0）</span>
<span class="kt">char</span> <span class="n">jay0</span><span class="p">[]</span> <span class="o">=</span> <span class="err">”</span><span class="n">jay</span><span class="err">”</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">jay1</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="err">”</span><span class="n">jay</span><span class="err">”</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">jay2</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'j'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">jay3</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'j'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="p">};</span>

<span class="c1">// 下面 2 个不是字符串</span>
<span class="kt">char</span> <span class="n">jay4</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="sc">'j'</span><span class="p">,</span> <span class="sc">'a'</span><span class="p">,</span> <span class="sc">'y'</span><span class="p">,</span> <span class="p">};</span>
<span class="kt">char</span> <span class="n">jay5</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="err">”</span><span class="n">jay</span><span class="err">”</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>对字符串函数（例如：<code class="language-plaintext highlighter-rouge">strlen(s)</code>）使用非字符串是 UB</ul><p>2 种数组：<strong>FLA</strong> 和 <strong>VLA</strong>（VLA 是到了 C99 才有的）</p><p>VLA 的一些特点：</p><ul><li>VLA 没有初始化<li>VLA 不能在 function 之外定义（只能在函数内部定义使用）</ul><p>VLA 的一个声明：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre> <span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="kt">double</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
</pre></table></code></div></div><h4 id="structure"><span class="mr-2">Structure</span><a href="#structure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>在声明 <code class="language-plaintext highlighter-rouge">struct</code> 时，使用 <code class="language-plaintext highlighter-rouge">typedef</code>，起到简化的作用（不需要每次都要加上 struct 关键字）：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">toto</span> <span class="n">toto</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">toto</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// 不需要加上 struct</span>
<span class="n">toto</span> <span class="n">one</span><span class="p">;</span>
</pre></table></code></div></div><ul><li><strong>opaque structure</strong>：就是不在头文件里面定义 struct。只在头文件里面声明 struct，同时头文件里面的函数的声明只会使用到这个 struct 的指针。例如：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="n">toto</span> <span class="n">toto</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">toto_doit</span><span class="p">(</span><span class="n">toto</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>但是，注意，不要 typedef 指向 struct 的指针</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// 不要这样做</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">toto_s</span><span class="o">*</span> <span class="n">toto</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">toto_doit</span><span class="p">(</span><span class="n">toto</span><span class="p">,</span> <span class="kt">unsigned</span><span class="p">);</span>
</pre></table></code></div></div><h3 id="线程"><span class="mr-2">线程</span><a href="#线程" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>本节介绍 C11 标准里使用<a href="#线程">线程</a>时会用到的几个基本库函数：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;threads.h&gt;</span><span class="cp">
</span><span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">thrd_start_t</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>

<span class="cm">/*
 * thrd_create 的 3 个入参说明如下：
 * thrd_t*：线程创建成功后的线程 id
 * thrd_start_t：线程执行的函数
 * void* 需要传入给线程的数据
 */</span>
<span class="kt">int</span> <span class="nf">thrd_create</span><span class="p">(</span><span class="n">thrd_t</span><span class="o">*</span><span class="p">,</span> <span class="n">thrd_start_t</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">thrd_join</span><span class="p">(</span><span class="n">thrd_t</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">);</span>
</pre></table></code></div></div><p>一般的使用方法：</p><ul><li>在 <code class="language-plaintext highlighter-rouge">main</code> 函数中，使用 <code class="language-plaintext highlighter-rouge">thrd_create</code> 函数对不同的任务创建相应的线程<li>然后在 <code class="language-plaintext highlighter-rouge">main</code> 函数中使用 <code class="language-plaintext highlighter-rouge">thrd_join</code> 对这些<a href="#线程">线程</a>做 <code class="language-plaintext highlighter-rouge">join</code>，等待这些<a href="#线程">线程</a>的结束<li>同时，某个<a href="#线程">线程</a>执行其对应的 <code class="language-plaintext highlighter-rouge">thrd_start_t</code> 函数，直到这个函数 <code class="language-plaintext highlighter-rouge">return</code>，该<a href="#线程">线程</a>的工作结束</ul><p>一个简单的例子：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cm">/* 先准备好需要提供给线程的数据：
   Create an object that holds the game's data. */</span>
<span class="n">life</span> <span class="n">L</span> <span class="o">=</span> <span class="n">LIFE_INITIALIZER</span><span class="p">;</span>
<span class="n">life_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">L</span><span class="p">,</span> <span class="n">n0</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">M</span><span class="p">);</span>

<span class="cm">/* Creates four threads that all operate on that same object
   and collects their IDs in ”thrd” */</span>
<span class="n">thrd_t</span> <span class="n">thrd</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
<span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thrd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">update_thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
<span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thrd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">draw_thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
<span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thrd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">input_thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>
<span class="n">thrd_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thrd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">account_thread</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">L</span><span class="p">);</span>

<span class="cm">/* Waits for the update thread to terminate */</span>
<span class="n">thrd_join</span><span class="p">(</span><span class="n">thrd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

<span class="cm">/* Tells everybody that the game is over */</span>
<span class="n">L</span><span class="p">.</span><span class="n">finished</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="n">ungetc</span><span class="p">(</span><span class="sc">'q'</span><span class="p">,</span> <span class="n">stdin</span><span class="p">);</span>

<span class="cm">/* Waits for the other threads */</span>
<span class="n">thrd_join</span><span class="p">(</span><span class="n">thrd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">thrd_join</span><span class="p">(</span><span class="n">thrd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">thrd_join</span><span class="p">(</span><span class="n">thrd</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>

<span class="c1">// 只有当这 4 个线程都结束时，main 函数才会结束</span>
</pre></table></code></div></div><p>使用线程的要点：</p><ul><li>如果某个<a href="#线程">线程</a>对一个「非原子」变量进行了写操作，那么其他<a href="#线程">线程</a><strong>同时</strong>对这个变量的「读写操作」会导致<a href="#线程">线程</a>执行的 UB（未定义行为）<li>使用 <code class="language-plaintext highlighter-rouge">_Atomic(T)</code> 语法定义「原子」变量。具体用法参考文档，这里只给简单的例子：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre> <span class="c1">// 不能作用到数组上。Invalid: atomic cannot be applied to arrays.</span>
<span class="k">_Atomic</span><span class="p">(</span><span class="kt">double</span><span class="p">[</span><span class="mi">45</span><span class="p">])</span> <span class="n">C</span><span class="p">;</span>

<span class="c1">// Valid: atomic can be applied to array base.</span>
<span class="k">_Atomic</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="n">D</span><span class="p">[</span><span class="mi">45</span><span class="p">];</span>
</pre></table></code></div></div><h3 id="tips"><span class="mr-2">Tips</span><a href="#tips" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><h4 id="类型"><span class="mr-2">类型</span><a href="#类型" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>C 语言中，有几种类型是不能直接做<strong>算术操作</strong>的。所谓的 <strong>narrow types</strong>：unsigned char / unsigned short / char / signed char / signed short / bool<li>在算术表达式中，narrow types 会被做一次 promote，成为 signed int 类型（而不是 unsigned int）；所以干脆最好不要在算术表达式中使用 narrow types<li>尽量使用 unsigned 类型；同时不要在算术表达式中把 unsigned 类型和 signed 类型混用<li>C 标准中的 stdint.h 头文件里面定义了固定 size 的整数。例如：uint32_t，int32_t 等。但到了具体平台上，并不是每种这些类型都存在</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;inttypes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">uint32_t</span> <span class="n">u</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>

<span class="c1">// 需要使用 PRIu32 来 printf 类型为 uint32_t 的值</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%"</span> <span class="n">PRIu32</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>非 scalar 类型的初始化必须使用 <code class="language-plaintext highlighter-rouge">{}</code>。例如：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">double</span> <span class="n">A</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">7</span><span class="p">.</span><span class="mi">8</span><span class="p">,</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">B</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="p">};</span>
<span class="kt">double</span> <span class="n">C</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">};</span>
</pre></table></code></div></div><ul><li><p>上面例子中数组 C 的初始化是 <strong>Designated Initializers</strong>（「指定初始化」，C99 标准支持）。尽量要使用 <strong>Designated Initializers</strong> 可以获得更好的 robust</p><li><p>另外，当不知道如何对类型 T 做初始化时，推荐使用 <strong>Default Initializers</strong>，<code class="language-plaintext highlighter-rouge">{ 0 }</code>。<strong>只要不是 VLA 类型</strong>，都可以使用 <strong>Default Initializers</strong>。例如：</p></ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">double</span> <span class="n">C</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
</pre></table></code></div></div><ul><li>「只读字符串」建议采用 <code class="language-plaintext highlighter-rouge">char const*const</code> 的形式，例如：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="k">const</span><span class="o">*</span><span class="k">const</span> <span class="n">bird</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> 
  <span class="err">”</span><span class="n">raven</span><span class="err">”</span><span class="p">,</span>
  <span class="err">”</span><span class="n">magpie</span><span class="err">”</span><span class="p">,</span>
  <span class="err">”</span><span class="n">jay</span><span class="err">”</span><span class="p">,</span>
<span class="p">};</span>
</pre></table></code></div></div><h4 id="function"><span class="mr-2">Function</span><a href="#function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Use <code class="language-plaintext highlighter-rouge">EXIT_SUCCESS</code> and <code class="language-plaintext highlighter-rouge">EXIT_FAILURE</code> as return values for <code class="language-plaintext highlighter-rouge">main</code> 函数<ul><li>这样做为移植性考虑：<code class="language-plaintext highlighter-rouge">main</code> 函数在有的平台期望 return 一个整数，而有的平台不希望 return 值</ul><li>满足 2 个特性的 function 叫 <strong>pure function</strong>：<ul><li>The function has no effects other than returning a value.<li>The function return value only depends on its parameters.</ul><li>当不能用 pure function 解决问题时，需要使用「指针」作为函数参数来解决问题<ul><li>pure function 就是只用值来传递参数，函数内部对参数的修改不会影响函数返回后入参的值</ul><li>如果 function 除了 return 之外，还有其他方式来改变「抽象状态机」的状态，那么就不是 pure function。例如：<ul><li>修改了「全局变量」<li>使用了 static 变量<li>做了 IO 操作</ul></ul><h4 id="指针"><span class="mr-2">指针</span><a href="#指针" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>pointer 用来 hold objects 的地址。objects 的 names 就是 variables<li><code class="language-plaintext highlighter-rouge">*</code> 号用来定义指针类型时，最好靠左：<code class="language-plaintext highlighter-rouge">int* p ＝ ＆n</code><li><code class="language-plaintext highlighter-rouge">*</code> 号用来「解引用」时，最好靠右：<code class="language-plaintext highlighter-rouge">int i ＝ *p</code><li>如果一个指针指向一个 array object，那么 array object 的长度不能通过对这个指针做 sizeof 操作得到<ul><li>指针不是数组<li>把指针作为函数的参数时，如果语义上这个指针是一个数组，需要也指定这个数组的长度</ul><li>对指针之间做减法，只能是当这些指针指向的是同一个 array object 时才行<ul><li>object 上做 sizeof，返回的结果的类型是：size_t<li>ptrdiff_t：指针之间相减以后的值的类型是 ptrdiff_t<li>使用 printf 打印一个指针时，用 p％，而且要把这个指针 cast 成 void*</ul><li>C 里面可以把一个类型的 object 强制解释成另外一个不同的类型。但不要这样做，这样做有一个专门的术语：<strong>trap representation</strong>，这是一种 UB 行为。一个指针只能指向 3 种目标：<ul><li>有效的 object<li>有效位置之后的一个位置<li>0（空值）</ul><li>总之，对一个 pointer 做 dereferenced 时，这个 pointer 指向的 object 必须有效，同时这个 pointer 指向的 object 的 type 必须是明确的（<strong>designated type</strong>）<li>C 里面有空指针的概念，但不能使用宏 NULL 来表示空指针（有坑。目前 C 标准对宏 NULL 的规定比较松散，不严格，底层具体的实现可能和平台相关）。目前推荐的做法是把指针赋值为 0 来表示空指针<li>数组可以被退化成指针。而且一旦退化成指针后，数组的其他信息就都丢失了</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// A 原先是一个数组，取地址后就退化成指针 p 了，后续使用 p 就是作为一个指针来使用</span>
<span class="kt">int</span> <span class="n">A</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></table></code></div></div><ul><li>把数组作为参数传给函数时，在数组参数之前增加一个参数来表示数组的长度：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// len 参数就是用来表示「数组参数」的长度</span>
<span class="c1">// 当然这个 len 的值是否正确，只能是靠程序员来保证了</span>
<span class="kt">double</span> <span class="nf">double_copy</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">double</span> <span class="n">target</span><span class="p">[</span><span class="n">len</span><span class="p">],</span> <span class="kt">double</span> <span class="k">const</span> <span class="n">source</span><span class="p">[</span><span class="n">len</span><span class="p">]);</span>
</pre></table></code></div></div><ul><li>能不用 <code class="language-plaintext highlighter-rouge">&amp;</code> 操作符（取一个 object 的地址），就不要用；引起潜在的问题（可以参考 Rust 的思想）<li><code class="language-plaintext highlighter-rouge">void *</code>：无类型的指针。任何对象的指针<strong>无需强转就</strong>可以转换为 <code class="language-plaintext highlighter-rouge">void*</code>，但也会损失掉这个对象的 type 信息<ul><li>尽管损失了 type 信息，但转换过程中 object 对应的 storage 实例是不会动的。在用强转回来以后，还能恢复原先的类型和数据（值能保持一致）<li>一种常见的做法是：函数的入参是一个 <code class="language-plaintext highlighter-rouge">void*</code> 参数和一个 <code class="language-plaintext highlighter-rouge">size_t</code> 的参数，这样的话，代表该函数要对一段固定长度（<code class="language-plaintext highlighter-rouge">size_t</code> 为单位）的内存做操作，而不关心这段内存中的数据的类型（例如：memcpy 和 memset）<li>还有一种常见情况：创建「线程」时「程序员」需要传递数据到线程中，pthread_create 函数有一个参数的类型就是 <code class="language-plaintext highlighter-rouge">void*</code>，其含义就是「程序员」可以传入任何类型的数据到线程中。当然，「程序员」自己知道这个 <code class="language-plaintext highlighter-rouge">void*</code> 是什么类型的，「程序员」会在「线程」中做一次 recast 把数据转换回到正确的类型。当然，这种 recast 的正确性完成由「程序员」保证。<li><code class="language-plaintext highlighter-rouge">void*</code> 还是能不用就尽量不用</ul><li><code class="language-plaintext highlighter-rouge">restrict</code> 关键字：用 restrict 修饰指针类型告诉「编译器」两个指针不指向同一数据（开发人员保证）。也就是该指针只会指向一个 object，不会 aliasing 其他对象<ul><li><strong>Pointer aliasing</strong>：是指两个或以上的指针指向同一数据</ul></ul><p>一个例子：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// memcpy 的定义使用了 restrict</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">memcpy</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="kr">restrict</span> <span class="n">s1</span><span class="p">,</span> <span class="kt">void</span> <span class="k">const</span><span class="o">*</span><span class="kr">restrict</span> <span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>

<span class="c1">// 而 memmove 不能使用 restrict（可能发生 Pointer aliasing）</span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">memmove</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">s1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">s2</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>一般来说，函数的参数的类型都是「指针」，而不能是「数组」。唯一的例外只是在对函数进行「声明」的时候，下面三种写法等价：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>     <span class="cm">/*写法1*/</span>
<span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[]);</span>    <span class="cm">/*写法2*/</span>
<span class="kt">int</span> <span class="nf">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]);</span>  <span class="cm">/*写法3：编译器会忽略 10 */</span>
</pre></table></code></div></div><ul><li>C99 中给出了「可变结构体」的标准定义。例如：</ul><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span>     <span class="n">length</span><span class="p">;</span>
    <span class="n">Point</span>   <span class="n">point</span><span class="p">[];</span> <span class="c1">// 这里不指定长度</span>
<span class="p">}</span> <span class="n">Polyline</span><span class="p">;</span>

<span class="c1">// 利用 malloc 对其进行初始化一个长度为 5 的结构体：</span>
<span class="n">Polyline</span><span class="o">*</span> <span class="n">polyline</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Polyline</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Point</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>
<span class="n">polyline</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</pre></table></code></div></div><h4 id="inline"><span class="mr-2">inline</span><a href="#inline" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>C99 引入了 inline 关键字：<ul><li>A function definition that is declared with inline can be used in several TUs without causing a multiple-symbol-definition error<li>All pointers to the same inline function will compare as equal, even if obtained in different TUs<li>An inline function that is not used in a specific TU will be completely absent from the binary of that TU and, in particular, will not contribute to its size</ul><li>inline 的一个关键点：<ul><li>An inline function definition is visible in all TUs. 但同时，编译器也不会保证一定会 emit 这个 inline 函数的符号。<ul><li>如果要确保该 inline 函数的符号被 emit，可以在 .c 文件中加一行不带 inline 的函数 declare 来确保 emit 函数的符号</ul></ul><li>总之，inline 函数的最佳实践如下：<ul><li>An inline definition goes in a header file<li>An additional declaration without <strong>inline</strong> goes in exactly one TU</ul></ul><p>例如一个头文件 toto.h 文件：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="c1">// toto.h 文件</span>
<span class="c1">// Inline definition in a header file.</span>
<span class="c1">// Function argument names and local variables are visible</span>
<span class="c1">// to the preprocessor and must be handled with care.</span>
<span class="kr">inline</span>
<span class="n">toto</span><span class="o">*</span> <span class="nf">toto_init</span><span class="p">(</span><span class="n">toto</span><span class="o">*</span> <span class="n">toto_x</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">toto_x</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">toto_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">toto</span><span class="p">){</span> <span class="mi">0</span> <span class="p">};</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">toto_x</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其对应的 toto.c 文件：</p><div class="language-c highlighter-rouge"><div class="code-header"> <span data-label-text="C"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cp">#include ”toto.h”
</span><span class="c1">// Instantiate in exactly one TU.</span>
<span class="c1">// The parameter name is omitted to avoid macro replacement.</span>
<span class="n">toto</span><span class="o">*</span> <span class="nf">toto_init</span><span class="p">(</span><span class="n">toto</span><span class="o">*</span><span class="p">);</span>

</pre></table></code></div></div><h4 id="其他"><span class="mr-2">其他</span><a href="#其他" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>再澄清一下几个概念<ul><li>semantic type：也就是语义上的类型。例如 int32_t（即 32 位的整数）<li>basic type：C 语言中的基本类型。例如 signed int（事实上 int32_t 是用 typedef 到 signed int）<li>binary representation：二进制表示。signed int 就是 b31, b30, … b7, … b0（32 个bits，4 个 bytes）<li>object representation：C 中所有的 object 都可以用 unsigned char 来表示。如果在一个小端系统中，上面的 binary representation 对应的 object representation 就是 unsigned char[4] 数组，且该数组的 [0] 是最高位，[3] 是最低位（小端系统）</ul><li>总之，C 对 object 的内存模型做了以下规定：<ul><li><code class="language-plaintext highlighter-rouge">sizeof(char)</code> 为 1（包括 3 种 char：unsigned char，signed char 和 char）<li>类型为 A 的 object 的 object representation 是一个数组：<code class="language-plaintext highlighter-rouge">unsigned char[sizeof(A)]</code><ul><li>但不要搞混了，object representation 的 char 是 unsigned char，不是 char<li>char 只能用于「字符类型」，或者「字符串类型」</ul></ul><li>cast：<strong>不要用 cast</strong>，坑巨多<li>Effective Type：对 object 的 access 进行限制。关键点如下：<ul><li>Objects must be accessed through their <strong>effective type</strong> or through a pointer to a character type<ul><li>union 是个例外：Any member of an object that has an effective union type can be accessed at any time, provided the byte representation amounts to a valid value of the access type</ul><li>The effective type of a variable or compound literal is the type of its declaration</ul><li>Files that are written in binary mode (fread, fwrite) are <strong>not portable</strong> between platforms</ul><h4 id="错误码"><span class="mr-2">错误码</span><a href="#错误码" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>一般还是不要用 errno 那一套方法（多线程环境不能用）。而是利用「枚举」来定义错误码，把错误码作为函数的返回值返回给「调用方」，并采用以 API 文档的形式定义错误码的具体含义。<ul><li>并且要用 API 的形式告诉「调用方」如何处理对应的错误；如果和「调用方」无关（或者说是「调用方」无法处理的错误）就不需要返回错误码给「调用方」了</ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E5%B7%A5%E5%85%B7/'>工具</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cmake/" class="post-tag no-text-decoration" >cmake</a> <a href="/tags/makefile/" class="post-tag no-text-decoration" >makefile</a> <a href="/tags/bazel/" class="post-tag no-text-decoration" >bazel</a> <a href="/tags/c/" class="post-tag no-text-decoration" >c</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Build Systems - Darktea&amp;url=https://darktea.github.io/posts/build-system/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Build Systems - Darktea&amp;u=https://darktea.github.io/posts/build-system/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://darktea.github.io/posts/build-system/&amp;text=Build Systems - Darktea" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/rust-notes/">Rust Notes</a><li><a href="/posts/build-system/">Build Systems</a><li><a href="/posts/On-Designing-and-Deploying-Internet-Scale-Services/">On Designing and Deploying Internet-Scale Services</a><li><a href="/posts/URL-Encoding/">URL Encoding</a><li><a href="/posts/memory-manager/">Linux 内存管理</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> <a class="post-tag" href="/tags/2pc/">2pc</a> <a class="post-tag" href="/tags/autotools/">autotools</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/bazel/">bazel</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/c/">c</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/autotools/"><div class="card-body"> <em class="timeago small" data-ts="1340467200" > 2012-06-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Autotools 使用入门</h3><div class="text-muted small"><p> 序. Intro 介绍 Autotools 的相关文章网上已经太多了，但这些文章要么是把一大堆工具列举出来，要么就是来一个 step by step 的例子。 但 Autotools 这套工具本身比较杂乱，罗列一堆工具，看了以后多半没有什么印象。 而 step by step 的例子做完一遍之后，也多半不知其所以然。 最好的入门材料还是 Autoconf 和 Automake 的官方...</p></div></div></a></div><div class="card"> <a href="/posts/git-notes/"><div class="card-body"> <em class="timeago small" data-ts="1370534400" > 2013-06-07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Git Notes</h3><div class="text-muted small"><p> 1. 新建远端 Git 仓库 先取好库的名字 (例如: myfirstrepo), 然后在 GitHub 等 Git 服务上建立新的 repository （参考具体服务帮助） 在 GitHub 上新建好库以后, 在本地新建目录 myfirstrepo. 然后执行 git init 然后 新建 README.md AUTHORS 文件. 提交到本地库的 master 分支上面...</p></div></div></a></div><div class="card"> <a href="/posts/right/"><div class="card-body"> <em class="timeago small" data-ts="1679587200" > 2023-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>右值引用</h3><div class="text-muted small"><p> 按 C++ 标准的发展来梳理出右值引用的概念。但会先复习一下引用的概念。 引用 先复习一下 C++ 中引用的概念： A reference defines an alternative name for an object 引用就是另外一个已经存在的对象的名字的别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/Jekyll-Chirpy-notes/" class="btn btn-outline-primary" prompt="上一篇"><p>Jekyll-Chirpy notes</p></a> <a href="/posts/working-on-it/" class="btn btn-outline-primary" prompt="下一篇"><p>Working on it</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/darktea">darktea</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> <a class="post-tag" href="/tags/2pc/">2pc</a> <a class="post-tag" href="/tags/autotools/">autotools</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/bazel/">bazel</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/c/">c</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>

<!DOCTYPE html><html lang="zh-CN" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.2.2" /><meta property="og:title" content="Rust Notes" /><meta property="og:locale" content="zh_CN" /><meta name="description" content="type ownership move borrowing copy references lifetime 函数定义使用生命周期注解 结构体的生命周期注解 pointers Box Rc RefCell collections vector slices hash map String string slice struct enum Patterns match module Attribute error panic Result 实现 Error Trait 日志 traits Drop Sized Clone Copy Deref and DerefMut Default AsRef and AsMut Borrow and BorrowMut From and Into input output Read BufRead Write threads Channels Arc async Future async/.await Pin 异步运行时 更多底层细节 closure Iterator 概念 获取 iterator 使用 iterator macros macro rules unsafe Unsafe Block Unsafe Function Unsafe Trait Raw Pointer" /><meta property="og:description" content="type ownership move borrowing copy references lifetime 函数定义使用生命周期注解 结构体的生命周期注解 pointers Box Rc RefCell collections vector slices hash map String string slice struct enum Patterns match module Attribute error panic Result 实现 Error Trait 日志 traits Drop Sized Clone Copy Deref and DerefMut Default AsRef and AsMut Borrow and BorrowMut From and Into input output Read BufRead Write threads Channels Arc async Future async/.await Pin 异步运行时 更多底层细节 closure Iterator 概念 获取 iterator 使用 iterator macros macro rules unsafe Unsafe Block Unsafe Function Unsafe Trait Raw Pointer" /><link rel="canonical" href="https://darktea.github.io/posts/rust-notes/" /><meta property="og:url" content="https://darktea.github.io/posts/rust-notes/" /><meta property="og:site_name" content="Darktea" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-23T00:00:00+08:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Rust Notes" /><meta name="twitter:site" content="@twitter_username" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-09T19:45:20+08:00","datePublished":"2022-02-23T00:00:00+08:00","description":"type ownership move borrowing copy references lifetime 函数定义使用生命周期注解 结构体的生命周期注解 pointers Box Rc RefCell collections vector slices hash map String string slice struct enum Patterns match module Attribute error panic Result 实现 Error Trait 日志 traits Drop Sized Clone Copy Deref and DerefMut Default AsRef and AsMut Borrow and BorrowMut From and Into input output Read BufRead Write threads Channels Arc async Future async/.await Pin 异步运行时 更多底层细节 closure Iterator 概念 获取 iterator 使用 iterator macros macro rules unsafe Unsafe Block Unsafe Function Unsafe Trait Raw Pointer","headline":"Rust Notes","mainEntityOfPage":{"@type":"WebPage","@id":"https://darktea.github.io/posts/rust-notes/"},"url":"https://darktea.github.io/posts/rust-notes/"}</script><title>Rust Notes | Darktea</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Darktea"><meta name="application-name" content="Darktea"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link rel="dns-prefetch" href="https://fonts.gstatic.com" crossorigin><link rel="preconnect" href="https://fonts.googleapis.com" ><link rel="dns-prefetch" href="https://fonts.googleapis.com" ><link rel="preconnect" href="https://cdn.jsdelivr.net" ><link rel="dns-prefetch" href="https://cdn.jsdelivr.net" ><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Lato&family=Source+Sans+Pro:wght@400;600;700;900&display=swap"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get MODE_ATTR() { return "data-mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } static get ID() { return "mode-toggle"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } let self = this; /* always follow the system prefers */ this.sysDarkPrefers.addEventListener("change", () => { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.notify(); }); } /* constructor() */ get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode === ModeToggle.DARK_MODE; } get isLightMode() { return this.mode === ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer)) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } setDark() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_ATTR, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_ATTR); sessionStorage.removeItem(ModeToggle.MODE_KEY); } /* Notify another plugins that the theme mode has changed */ notify() { window.postMessage({ direction: ModeToggle.ID, message: this.modeStatus }, "*"); } } /* ModeToggle */ const toggle = new ModeToggle(); function flipMode() { if (toggle.hasMode) { if (toggle.isSysDarkPrefer) { if (toggle.isLightMode) { toggle.clearMode(); } else { toggle.setLight(); } } else { if (toggle.isDarkMode) { toggle.clearMode(); } else { toggle.setDark(); } } } else { if (toggle.isSysDarkPrefer) { toggle.setLight(); } else { toggle.setDark(); } } toggle.notify(); } /* flipMode() */ </script><body data-spy="scroll" data-target="#toc" data-topbar-visible="true"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src=" /assets/img/favicons/android-chrome-512x512.png " alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Darktea</a></div><div class="site-subtitle font-italic">Know nothing</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>首页</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>分类</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>标签</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>归档</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>关于</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <button class="mode-toggle btn" aria-label="Switch Mode"> <i class="fas fa-adjust"></i> </button> <span class="icon-border"></span> <a href="https://github.com/darktea" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://twitter.com/twitter_username" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['tiantianding','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> 首页 </a> </span> <span>Rust Notes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> 文章</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="搜索..."> </span> <span id="search-cancel" >取消</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="core-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Rust Notes</h1><div class="post-meta text-muted"><div> 作者 <em> <a href="https://github.com/darktea">darktea</a> </em></div><div class="d-flex"><div> <span> 发表于 <em class="timeago" data-ts="1645545600" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2022-02-23 </em> </span> <span> 更新于 <em class="timeago" data-ts="1712663120" data-toggle="tooltip" data-placement="bottom" data-tooltip-df="llll" > 2024-04-09 </em> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="29446 字"> <em>163 分钟</em>阅读</span></div></div></div><div class="post-content"><ul><li><a href="#type">type</a><li><a href="#ownership">ownership</a><li><a href="#move">move</a><li><a href="#borrowing">borrowing</a><li><a href="#copy">copy</a><li><a href="#references">references</a><li><a href="#lifetime">lifetime</a><ul><li><a href="#函数定义使用生命周期注解">函数定义使用生命周期注解</a><li><a href="#结构体的生命周期注解">结构体的生命周期注解</a></ul><li><a href="#pointers">pointers</a><ul><li><a href="#box">Box</a><li><a href="#rc">Rc</a><li><a href="#refcell">RefCell</a></ul><li><a href="#collections">collections</a><ul><li><a href="#vector">vector</a><li><a href="#slices">slices</a><li><a href="#hash-map">hash map</a><li><a href="#string">String</a><li><a href="#string-slice">string slice</a></ul><li><a href="#struct">struct</a><li><a href="#enum">enum</a><ul><li><a href="#patterns">Patterns</a></ul><li><a href="#match">match</a><li><a href="#module">module</a><ul><li><a href="#attribute">Attribute</a></ul><li><a href="#error">error</a><ul><li><a href="#panic">panic</a><li><a href="#result">Result</a><li><a href="#实现-error-trait">实现 Error Trait</a><li><a href="#日志">日志</a></ul><li><a href="#traits">traits</a><ul><li><a href="#drop">Drop</a><li><a href="#sized">Sized</a><li><a href="#clone">Clone</a><li><a href="#copy">Copy</a><li><a href="#deref-and-derefmut">Deref and DerefMut</a><li><a href="#default">Default</a><li><a href="#asref-and-asmut">AsRef and AsMut</a><li><a href="#borrow-and-borrowmut">Borrow and BorrowMut</a><li><a href="#from-and-into">From and Into</a></ul><li><a href="#input-output">input output</a><ul><li><a href="#read">Read</a><li><a href="#bufread">BufRead</a><li><a href="#write">Write</a></ul><li><a href="#threads">threads</a><ul><li><a href="#channels">Channels</a><li><a href="#arc">Arc</a></ul><li><a href="#async">async</a><ul><li><a href="#future">Future</a><li><a href="#asyncawait">async/.await</a><li><a href="#pin">Pin</a><li><a href="#异步运行时">异步运行时</a><li><a href="#更多底层细节">更多底层细节</a></ul><li><a href="#closure">closure</a><li><a href="#iterator">Iterator</a><ul><li><a href="#概念">概念</a><li><a href="#获取-iterator">获取 iterator</a><li><a href="#使用-iterator">使用 iterator</a></ul><li><a href="#macros">macros</a><ul><li><a href="#macro-rules">macro rules</a></ul><li><a href="#unsafe">unsafe</a><ul><li><a href="#unsafe-block">Unsafe Block</a><li><a href="#unsafe-function">Unsafe Function</a><li><a href="#unsafe-trait">Unsafe Trait</a><li><a href="#raw-pointer">Raw Pointer</a></ul></ul><h2 id="type"><span class="mr-2">type</span><a href="#type" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>不变：一旦一个变量绑定了一个值，就不能被绑定到其他值上面<li>可变：该变量可以被绑定到其他值上<li>不变 vs. shadowing：shadowing 相当于创建了一个新的变量<li>静态语言：编译时就要知道所有变量的类型<li>标量：整型（有符号和无符号都支持），浮点（f32 和 f64），布尔，字符（注意：不是字符串）<li>复合类型：tup, array（stack上，固定长度）<li>字符串常量（<a href="#string-slice">string literal</a>）vs. <a href="#string">String</a> 类型：前者在栈上？（运行期不可变），后者在堆上（运行期可变）<li>const 和 变量的区别：<ul><li>const 是编译期可决定的值（或表达式）<li>可以在函数之外定义一个 const，在 module 的范围内使用这个 const<li>const 更快</ul><li>type 关键字：给某个类型声明一个新的名字。例如：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">type</span> <span class="n">Bytes</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">decode</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>

<span class="c1">// 给每个 module 定义一个 Result 的 alias</span>
<span class="c1">// 一般来说，某个 module 内，使用同一个 Error，使用这种 alias 就可以简化 Result 的书写</span>
<span class="k">pub</span> <span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><h2 id="ownership"><span class="mr-2">ownership</span><a href="#ownership" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p><strong>Note</strong>：「变量」（variable）拥有「值」（value）</p></blockquote><p>所有权（ownership）3 原则：</p><ol><li>Rust 中每一个值都有一个称之为其「所有者」（owner）的「变量」<li>「值」有且只能有一个所有者（「变量」）<li>当所有者（「变量」）离开作用域，这个「值」将被丢弃，同时其资源也被释放</ol><blockquote><p><strong>思考</strong>：使用 C 语言的时候，如果遵循这 3 个原则来使用指针？</p></blockquote><p>对复合数据结构，所有权可以是「树状结构」。例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 定义一个 struct：Person</span>
    <span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">birth</span><span class="p">:</span> <span class="nb">i32</span>
    <span class="p">}</span>

    <span class="c1">// 使用 let 来创建值或者资源，同时该「变量」成为「值」的 owner</span>
    <span class="c1">// 一个 Person 的 Vector</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">composers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// Vector 中放入 3 个 structs</span>
    <span class="n">composers</span><span class="nf">.push</span><span class="p">(</span><span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Palestrina"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">birth</span><span class="p">:</span> <span class="mi">1525</span> <span class="p">});</span>
    <span class="n">composers</span><span class="nf">.push</span><span class="p">(</span><span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Dow"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">birth</span><span class="p">:</span> <span class="mi">1563</span> <span class="p">});</span>
    <span class="n">composers</span><span class="nf">.push</span><span class="p">(</span><span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="s">"Lully"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="n">birth</span><span class="p">:</span> <span class="mi">1632</span> <span class="p">});</span>

    <span class="c1">// composers 是所有权树的 root，其拥有 3 个 structs</span>
    <span class="c1">// 每个 struct 又拥有 2 个字段</span>
    <span class="c1">// struct 中的字段 name，又拥有其对应的「值」（文本内容）</span>
    <span class="c1">// 从而形成了一个「所有权树」</span>
<span class="p">}</span>
<span class="c1">// 离开作用域，从所有权树的 root 节点 composers 开始释放整个树</span>
</pre></table></code></div></div><p>另外一个例子，使用了 Box 类型：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// A Box&lt;T&gt; is a pointer to a value of type T stored on the heap</span>
    <span class="c1">// Box::new 在 heap 上给一个 tuple 分配空间，然后指向分配的空间的指针</span>
    <span class="k">let</span> <span class="n">point</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">((</span><span class="mf">0.625</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">));</span>
<span class="p">}</span>
<span class="c1">// 离开作用域，释放 head 上分配的空间</span>
</pre></table></code></div></div><p>除了上面的基本规则，ownership 还有几个扩展概念，这里只提一下，后面的章节会深入细节：</p><ul><li>可以把「值」从一个 owner 移交给另外一个 owner，也就是 <strong>move</strong><li>一些简单类型（Integer，char），默认不遵守所有权规则，这些类型统称为 <strong>Copy Type</strong><li>利用 Rc，Arc 等指针机制，一个「值」可以有几个 owners<li>除了 own 一个值，Rust 还提供了另外一种机制来访问值：<strong>borrow</strong></ul><h2 id="move"><span class="mr-2">move</span><a href="#move" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><strong>move</strong>：把「值」的所有权转移给另外一个「变量」（owner）<ul><li>赋值（=），传递「函数参数」，返回「函数返回值」都会发生 move</ul><li>一旦某个「变量」的所有权转移（move）走了以后，该「变量」失效，不能再使用这个「变量」<ul><li>例如：在【函数】和【闭包】中，在入参是 move 的场景（而不是 borrow 的场景），进入函数后，参数和返回值的 owner 关系发生改变，原先的变量不再有效</ul><li>可以通过实现 Copy trait 把默认的 move 改成 copy（复制，类似深拷贝）<ul><li>Rust 中，一些简单类型，默认实现了 Copy trait，这些类型统称为 <strong>Copy Type</strong><li>Copy trait 继承了 Clone trait</ul></ul><p>一个函数入参是 move 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"abc"</span><span class="p">);</span>

    <span class="c1">// 该字符串的 ownership 被 move，之后 s1 失去了这个字符串的 ownership，s1 不再有效</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
    <span class="c1">// 不能再使用 s1（已经发生了 move）</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The length is {}."</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// move</span>
<span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="c1">// 函数内部拿到了这个字符串的 ownership</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
    <span class="c1">// 当函数结束的时候，这个字符串被 dropped</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>和大部分类型不同，Copy Type（例如：integers，整型）不使用 move 规则，而是进行 copy。例如：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// copy</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="c1">// bind the value 5 to x</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// make a COPY of the value in x and bind it to y</span>

    <span class="c1">// move</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span> <span class="c1">// s1 was moved into s2。之后 s1 不再有效</span>

    <span class="c1">// clone</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="nf">.clone</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其它一些要点：</p><ul><li>不能把 Vector 中的单个 element move out。例如：let third = v[2]<ul><li>这种场景可以使用 borrow。除了 <strong>move</strong> 之外，还可以 <strong>borrow</strong> 一个「值」（后面会详细说）</ul></ul><h2 id="borrowing"><span class="mr-2">borrowing</span><a href="#borrowing" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p><strong>借用</strong> (borrowing)：对函数参数来说，如果不想 ownership 发生变化可以利用引用（reference）。下面给一个简单的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="c1">// 把 s1 的引用（&amp;s1）作为参数传给函数，这样就可以达到 borrowing 的效果：s1 对这个字符串值的 ownership 不变</span>
    <span class="k">let</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="c1">// s1 依旧是这个字符串值的 owner，可以使用</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The length of '{}' is {}."</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 借用：使用引用（&amp;String）作为函数的入参</span>
<span class="k">fn</span> <span class="nf">calculate_length</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="c1">// 函数内部使用引用 s（borrowing 到一个字符串的值）</span>
    <span class="n">s</span><span class="nf">.len</span><span class="p">()</span>
    <span class="c1">// 当函数结束的时候，这个引用 s 本身（s 本身也是类型为引用的值）被 dropped</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>要想在函数内部修改借用的参数的值，需要利用「可变引用」：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="nf">change</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">change</span><span class="p">(</span><span class="n">some_string</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">some_string</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">", world"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p><strong>NOTE</strong>：</p><p>为啥不需要对这个可变引用进行 deference（类似 C 语言中的 * 操作符）？</p><p>(*some_string).push_str(“, world”);</p><p>这是因为在「method」或者「field」上的 . 操作符可以自动 deference 引用。也就是说在这种场景，不需要区分是引用还是值，直接使用 . 操作符就行了：</p><p>some_string.push_str(“, world”);</p><p>但对于其他场景，还是需要进行 deference，例如：</p><p>(*some_string) = String::from(“new string it”);</p></blockquote><h2 id="copy"><span class="mr-2">copy</span><a href="#copy" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>默认是 copy 而不是 move 的类型有：</p><ul><li>integer<li>floating-point numeric<li>char<li>bool<li>A tuple or fixed-size array of Copy types is itself a Copy type</ul><h2 id="references"><span class="mr-2">references</span><a href="#references" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><strong>定义</strong>：The &amp;s1 syntax lets us create a reference that refers to the value of s1 but does not own it<ul><li><strong>翻译</strong>：s1 是一个值；而 &amp;s1 就是指向这个值的「引用」（但并不 own 这个值）</ul><li>Rust 提供了「引用」这种方式来 access 一个 value：可使用 value，但不 own 这个 value。又分为 2 种「引用」：<ul><li>&amp;T；「shared 引用」；多个 「shared 引用」可共享同一个 value，但不能修改这个 value<li>&amp;mut T；「可变引用」；不能共享同一个 value，但可以修改这个 value</ul></ul><p>和普通类型一样，引用实际上也是类型：</p><ul><li>i32：一个整数类型（32 位）<li>&amp;i32：一个指向 i32 的不变引用类型<li>&amp;mut i32：一个指向 i32 的可变引用类型</ul><p>引用两原则：</p><ul><li>At any given time, you can have either (but not both of) one mutable reference or any number of immutable references<ul><li>在给定作用域中的给定值有且只有一个「可变引用」<li>if we have an immutable reference to something, we cannot also take a mutable reference</ul><li>References must always be valid<ul><li>值的生命周期必须比指向它的引用的生命周期大（outlives）<li>如果被引用的值失效了（被 drop 掉），这个引用也就失效了<ul><li><strong>在给定作用域中的给定值已经存在引用，也不能对一个值的 owner 进行 move</strong>：因为一旦对这个值的 owner 进行 move 操作，这个值就会被 drop 掉，就导致这个值上的引用失效</ul></ul></ul><blockquote><p><strong>注意</strong></p><p>引用原则中的【作用域】指的是：从创建开始，一直持续到它<strong>最后一次使用</strong>的地方，而不是从创建持续到某一个花括号</p></blockquote><p>请仔细对比以下 2 个例子，一个【合法】，一个【非法】：</p><p>【合法】：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nd">#[allow(unused_assignments)]</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 变量 s 对该 String 值有 ownership</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"12345"</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// r 是到 s 的「可变引用」，或者可以说：“引用 r is a borrow of 变量 s”</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>

    <span class="c1">//【合法】：使用「可变引用」 r 对值进行修改</span>
    <span class="c1">// 而且这里是 r 【最后一次】被使用的地方</span>
    <span class="n">r</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"67890"</span><span class="p">);</span>

    <span class="c1">//【合法】：因为这里已经不是引用 r 的作用范围（已经在最后一次使用之后了）</span>
    <span class="c1">// 所以满足原则：“在给定作用域中的给定值已经存在引用，也不能对一个值的 owner 进行 move”</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"123456789012345"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>【非法】：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nd">#[allow(unused_assignments)]</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 变量 s 对该 String 值有 ownership</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"12345"</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// r 是到 s 的「可变引用」，或者可以说：“引用 r is a borrow of 变量 s”</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">;</span>

    <span class="c1">//【合法】：使用「可变引用」 r 对值进行修改</span>
    <span class="n">r</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">"67890"</span><span class="p">);</span>

    <span class="c1">//【非法】：因为这里还在引用 r 的作用范围之内（之后还使用了 r.len，不是【最后一次】被使用）</span>
    <span class="c1">// 所以违反了原则：“在给定作用域中的给定值已经存在引用，也不能对一个值的 owner 进行 move”</span>
    <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"123456789012345"</span><span class="p">);</span>

    <span class="c1">// r 还在被使用</span>
    <span class="n">r</span><span class="nf">.len</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>总之：</p><p>owner 和 可变引用的根本区别就在于 owner 会负责值的 drop（释放）；这个区别也就决定了一旦值上存在引用，就要小心的使用 owner，要保证这个值要始终有效，不要被释放，否则 Rust 的编译器会提示失败。</p></blockquote><p>另外，Rust 中，可以「引用」到任意的表达式，包括「值」，例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.product</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="nf">factorial</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

<span class="c1">// Arithmetic operators can see through one level of references. </span>
<span class="c1">// 可以是 r + &amp;1009 这种形式</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="o">&amp;</span><span class="mi">1009</span><span class="p">,</span> <span class="mi">1729</span><span class="p">);</span>
</pre></table></code></div></div><p>上面的例子中，Rust 会创建一个「匿名变量」来 hold 这个表达式的「值」，然后让这个「引用」指向这个「匿名变量」，而这个「匿名变量」也有它自己的<a href="#lifetime">生命周期</a>。</p><h2 id="lifetime"><span class="mr-2">lifetime</span><a href="#lifetime" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p><strong>【生命周期】原则：一个引用的生命周期不能超过其引用的变量的有效期</strong></p></blockquote><ul><li>Rust 中，【生命周期】的概念只和变量的<strong>引用</strong>有关；Rust 中所有的引用都会关联一个「生命周期」<li>【生命周期】是程序可以安全使用这个<strong>引用</strong>的一个范围<li>【生命周期注解】告诉 Rust 多个引用的生命周期如何相互联系</ul><h3 id="函数定义使用生命周期注解"><span class="mr-2">函数定义使用生命周期注解</span><a href="#函数定义使用生命周期注解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>先给一个在函数中使用<strong>生命周期注解</strong>的例子：</p><ul><li>告诉 Rust 这 3 个引用的【生命周期】的关系；返回值的生命周期和「两个入参」的生命周期相同：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="n">longest</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">x</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">y</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">x</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">y</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>编译时，会检查其是否符合生命周期原则：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"long string is long"</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xyz"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// 内层代码块的结束</span>
<span class="p">}</span>
</pre></table></code></div></div><p>检查过程如下：</p><ul><li>这里 2 个入参的生命周期 ‘a，是 string1 和 string2 这 2 个参数作用域重叠的部分（内层代码块的结束之前）<li>返回值 result 的生命周期也是 ‘a（string1 和 string2 这 2 个参数作用域重叠的部分）<li>那么 println! 使用 result 的时候，’a 是有效的（内层代码块的结束之前），所以<strong>符合生命周期原则</strong></ul><p>再来一个<strong>不符合生命周期原则</strong>的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">string1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"long string is long"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">string2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"xyz"</span><span class="p">);</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nf">longest</span><span class="p">(</span><span class="n">string1</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="n">string2</span><span class="nf">.as_str</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"The longest string is {}"</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>这个例子中返回值 result 的生命周期也同样是：string1 和 string2 这 2 个参数作用域重叠的部分<li>但 println! 使用 result 的时候，已经超出了 ‘a 的有效范围（内层代码块的结束之后），所以<strong>不符合生命周期原则</strong></ul><h3 id="结构体的生命周期注解"><span class="mr-2">结构体的生命周期注解</span><a href="#结构体的生命周期注解" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>结构体的生命周期注解：结构内有引用的话，结构体本身的生命周期必须和其中引用的对象的生命周期保持一致</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">struct</span> <span class="n">ImportantExcerpt</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">part</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">novel</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Call me Ishmael. Some years ago..."</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">first_sentence</span> <span class="o">=</span> <span class="n">novel</span><span class="nf">.split</span><span class="p">(</span><span class="sc">'.'</span><span class="p">)</span>
        <span class="nf">.next</span><span class="p">()</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"Could not find a '.'"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ImportantExcerpt</span> <span class="p">{</span> <span class="n">part</span><span class="p">:</span> <span class="n">first_sentence</span> <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后详细分析一个生命周期的例子。</p><p>先定义一个结构体 S：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">i32</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后在下面这段代码中使用这个结构体（具有 2 层代码块）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="n">S</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">y</span> <span class="p">};</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">s</span><span class="py">.x</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// 内层代码块的结束</span>
<span class="p">}</span> <span class="c1">// 外层代码块的结束</span>
</pre></table></code></div></div><p>检查过程如下：</p><ul><li>结构体 S 的 2 个引用字段有相同的生命周期 ‘a<li>这个例子中，生命周期 ‘a 为变量 x 和 y 的重叠部分（也就是<strong>内层代码块的结束</strong>）<li>变量 s 的生命周期也要和这 2 个字段的生命周期 ‘a 相同，所以变量 s 的生命周期也必须是 x 和 y 这 2 个变量的重叠部分（也是<strong>内层代码块的结束</strong>）<li>但 r = s.x 这个赋值语句要求 s 生命周期 ‘a 也必须能涵盖 r 的生命周期（也就是说 ‘a 不能比 r 先结束而失效）<li>但实际上 r 的有效期需要到<strong>外层代码块结束</strong><li>最终检查结果是：不符合「生命周期原则」</ul><p>解决方法是修改结构体 S 的定义：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">S</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="nv">'b</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">x</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">i32</span><span class="p">,</span>
    <span class="n">y</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'b</span> <span class="nb">i32</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="pointers"><span class="mr-2">pointers</span><a href="#pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><blockquote><p>实际上，Rust 中的 Smart Points（以及<a href="#traits">常用 Traits</a>）就是给开发人员提供了 Rust 中一些惯用模式。</p></blockquote><p>Rust 中的指针有 3 种：</p><ul><li>【引用】：Rust 中安全的指针。也就是【非所有权指针】，分 &amp;T 和 &amp;mut T 两种。其中 &amp;T 本身是一种 Copy 类型；而 &amp;mut T 并没有实现 Copy Trait（Copy <strong>trait</strong> 的细节请参考其他小节）<li>【原始指针】：也就是 Raw Points，用于 <a href="#unsafe">unsafe</a> 代码；这里不详细介绍了<li>【智能指针】：智能指针的 2 个关键 <strong>trait</strong>：Drop（离开作用域后，自动释放资源） 和 Deref。标准库提供了几种智能指针：Box&lt;T&gt;，Rc&lt;T&gt;，Arc&lt;T&gt;，Cell&lt;T&gt;，RefCell&lt;T&gt;</ul><p>下面是对其中一些【智能指针】的介绍。</p><h3 id="box"><span class="mr-2">Box</span><a href="#box" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使用 Box 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">84</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>
    <span class="p">}</span> <span class="c1">// 该 scope 结束后，不但 z 被释放，而且 y 也被释放（因为 y 这个变量是用 Box::new 来初始化的，所以用 y 来构建 z 的时候是 move，而不是 copy）</span>

    <span class="k">let</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 能通过生命周期检查</span>
    <span class="k">let</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span> <span class="c1">// 不能通过生命周期检查，因为 y 已经被释放</span>
<span class="p">}</span>
</pre></table></code></div></div><p>既然 <a href="#box">Box</a> 用于把数据存储在「堆」（heap）上，那么 <a href="#box">Box</a> 常常被使用在以下场景：</p><ul><li>在编译时，无法确认数据 size 的场景<li>不关心当前「对象」具体的「类型」，而是只关心它实现了什么 <a href="#traits">Trait</a></ul><p>下面是一个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 错：这个定义是不能通过编译的。因为 List 的这个定义是递归的，在编译期间不能决定 List 的 size</span>
<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="n">List</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><p>改用 Box 可通过编译：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="rc"><span class="mr-2">Rc</span><a href="#rc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>如果上一节例子中的某个 List 节点被多个 List 指向怎么办？如果还是使用 <a href="#box">Box</a> 指针不能通过编译：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Box</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">))));</span>
    <span class="c1">// b 获取到了 a 的「所有权」</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

    <span class="c1">// 错：这里不能通过编译，a 的「所有权」已经被 b 占有</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这种场景需要使用 Rc（单个 value 可以有多个 owners）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="k">enum</span> <span class="n">List</span> <span class="p">{</span>
    <span class="nf">Cons</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="nb">Nil</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nf">Cons</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nb">Nil</span><span class="p">)))));</span>
    <span class="c1">// b 获取到了 a 的「所有权」，引用计数 +1</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>

    <span class="c1">// c 也获取到了 a 的「所有权」，引用计数 +1</span>
    <span class="k">let</span> <span class="n">c</span> <span class="o">=</span> <span class="nf">Cons</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其他使用 Rc 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">rc</span><span class="p">::</span><span class="nb">Rc</span><span class="p">;</span>

<span class="c1">// Rust can infer all these types; written out for clarity</span>
<span class="k">let</span> <span class="n">s</span><span class="p">:</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Rc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"hello it"</span><span class="nf">.to_string</span><span class="p">());</span>
<span class="k">let</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.clone</span><span class="p">();</span>
<span class="k">let</span> <span class="n">u</span><span class="p">:</span> <span class="nb">Rc</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.clone</span><span class="p">();</span>
</pre></table></code></div></div><blockquote><p>A value in an Rc box is always shared and therefore always immutable.</p><p>翻译：Rc 中的 value 总是被共享的值，也就是说，这个 value 是「不可变的」，可读但不可写。</p></blockquote><h3 id="refcell"><span class="mr-2">RefCell</span><a href="#refcell" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>为了解决「内部可变」（<strong>interior mutability</strong> ）问题，可以使用 <a href="#refcell">RefCell</a> 指针。</p><p>所谓 <strong>interior mutability</strong> 问题<strong>持有不可变引用又需要修改其中的 value</strong>（而不像 <a href="#rc">Rc</a> 中的值是「不可变的」）。</p><p>正常来说，不能对「不变量」进行「可变引用」：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="k">mut</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// 编译错：不能对「不变量」进行「可变引用」</span>
</pre></table></code></div></div><p>但有时候，开发人员需要对一个不变引用中的 value 做可变（修改这个 value 的值），这时候就可以使用 <a href="#refcell">RefCell</a>。</p><p>例如，要实现一个 <code class="language-plaintext highlighter-rouge">trait</code>，该 <code class="language-plaintext highlighter-rouge">trait</code> 的定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">Student</span> <span class="p">{</span>
    <span class="c1">// 用于接收老师消息，注意这里的 &amp;self 是不可变引用</span>
    <span class="k">fn</span> <span class="nf">on_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">on_message</code> 的定义限制了 self 是「不可变」的，但我们又希望在 <code class="language-plaintext highlighter-rouge">on_message</code> 中改变。那么解决方法如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span> <span class="c1">// 从标准库中引入</span>

<span class="k">struct</span> <span class="n">Boy</span> <span class="p">{</span>
    <span class="n">messages</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="c1">// messages 的类型为 RefCell</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Boy</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Boy</span> <span class="p">{</span>
        <span class="n">Boy</span> <span class="p">{</span>
            <span class="n">messages</span><span class="p">:</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[])</span>  <span class="c1">// 将 vec 保存在 RefCell 中</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Student</span> <span class="k">for</span> <span class="n">Boy</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">on_message</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// self 仍然是不可变引用</span>
        <span class="c1">// 在运行时借用可变引用类型的 messages</span>
        <span class="k">self</span><span class="py">.messages</span><span class="nf">.borrow_mut</span><span class="p">()</span><span class="nf">.push</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">message</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p><a href="#refcell">RefCell</a> 中包含一个可变引用（mut reference）。</p><p><code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> is a generic type that contains a single value of type T. <code class="language-plaintext highlighter-rouge">RefCell</code> supports borrowing references to its <code class="language-plaintext highlighter-rouge">T</code> value：</p><ul><li><code class="language-plaintext highlighter-rouge">RefCell::new(value)</code>。Creates a new RefCell, <strong>moving</strong> value into it.<li><code class="language-plaintext highlighter-rouge">ref_cell.borrow()</code>。Returns a <code class="language-plaintext highlighter-rouge">Ref&lt;T&gt;</code>, which is essentially just a <strong>shared reference</strong> to the value stored in ref_cell. This method <strong>panics</strong> if the value is already mutably borrowed<li><code class="language-plaintext highlighter-rouge">ref_cell.borrow_mut()</code>。Returns a <code class="language-plaintext highlighter-rouge">RefMut&lt;T&gt;</code>, essentially a <strong>mutable reference</strong> to the value in ref_cell. This method <strong>panics</strong> if the value is already borrowed<li><code class="language-plaintext highlighter-rouge">ref_cell.try_borrow(), ref_cell.try_borrow_mut()</code>。Work just like borrow() and borrow_mut(), but return a Result. Instead of <strong>panics</strong> if the value is already mutably borrowed, they return an <strong>Err value</strong></ul><p>一个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cell</span><span class="p">::</span><span class="n">RefCell</span><span class="p">;</span>
<span class="k">let</span> <span class="n">ref_cell</span><span class="p">:</span> <span class="n">RefCell</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">RefCell</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="s">"hello"</span><span class="nf">.to_string</span><span class="p">());</span>
<span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="n">ref_cell</span><span class="nf">.borrow</span><span class="p">();</span> <span class="c1">// ok, returns a Ref&lt;String&gt;</span>
<span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">r</span><span class="nf">.len</span><span class="p">();</span> <span class="c1">// ok, returns "hello".len()</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">w</span> <span class="o">=</span> <span class="n">ref_cell</span><span class="nf">.borrow_mut</span><span class="p">();</span> <span class="c1">// panic: already borrowed</span>
<span class="n">w</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" world"</span><span class="p">);</span>
</pre></table></code></div></div><p>其实 <a href="#refcell">RefCell</a> 的使用规则和普通的「引用」基本一致，唯一的区别就是使用普通「应用」时违反规则的话，会在「编译期」给出错误提示；而使用 <a href="#refcell">RefCell</a> 违背规则的话，会在运行时 <strong>panic</strong>。</p><p>另外：</p><blockquote><p>将 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> 和 <code class="language-plaintext highlighter-rouge">RefCell&lt;T&gt;</code> 结合使用来实现一个拥有多重所有权的可变数据。</p><p>但这种做法不是线程安全的，常用于用 Rust 刷算法题，并不会用到工程上。</p></blockquote><p>总之，<a href="#refcell">RefCell</a> 提供了一种在编译期间绕过 Rust 不变性检查的方法；但同时也付出了复杂性的代价。</p><h2 id="array"><span class="mr-2">array</span><a href="#array" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust 中表示内存中连续的值的序列的类型有 3 种：</p><ul><li>Array：<code class="language-plaintext highlighter-rouge">[T; N]</code><li><code class="language-plaintext highlighter-rouge">Vector：Vec&lt;T&gt;</code><li><code class="language-plaintext highlighter-rouge">Slice：&amp;[T]</code> 和 `&amp;mut [T]</ul><blockquote><p>这 3 种形式中 <code class="language-plaintext highlighter-rouge">v[i]</code> 都代表的是第 i 个元素。</p></blockquote><p>这里介绍 Array（Vector 的介绍放到后面<a href="#vector">一节</a>）：</p><ul><li><code class="language-plaintext highlighter-rouge">[T; N]</code> 表达的是有 N 个值的数组，且该数组中的每个元素的类型是 T<ul><li><code class="language-plaintext highlighter-rouge">[T; N]</code> 形态的数组必须在编译期就决定该数组的大小和类型，同时该数组的大小不能再变化</ul></ul><blockquote><p>这里也先提一下 Slice：<code class="language-plaintext highlighter-rouge">&amp;[T]</code> 和 <code class="language-plaintext highlighter-rouge">&amp;mut [T]</code> 表达的是另外一个内存中连续的值的序列（Array 或 Vector）的 <strong>slice</strong></p></blockquote><h2 id="collections"><span class="mr-2">collections</span><a href="#collections" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>collections 存放的是指向 heap 上的数据的指针的集合（和 array/tuple 不一样）：<ul><li>vector：可变长度，并且存放同种类型的元素<li>string：Rust 标准库提供了 String 类型<li>hash map</ul></ul><h3 id="vector"><span class="mr-2">vector</span><a href="#vector" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>一些创建 vector 的例子：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// 使用 vec! macro</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">primes</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">];</span>
    <span class="c1">// 变长</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">z</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">rows</span> <span class="o">*</span> <span class="n">cols</span><span class="p">];</span>

<span class="c1">// 使用 Vec::new</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pal</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">pal</span><span class="nf">.push</span><span class="p">(</span><span class="s">"step"</span><span class="p">);</span>

<span class="c1">// 使用 iterator</span>
    <span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">)</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>容量不等于 vector 的当前面 size：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// capacity 是 2，但 size 是 0</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="nf">.capacity</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>两种方法获取 vector 中的某个元素<ul><li>let does_not_exist = &amp;v[100]; // 直接 panic，如果数组的 size 小于 100<li>let does_not_exist = v.get(100); // 返回 None，如果数组的 size 小于 100</ul><li>下面代码编译时直接报错：first 是不变引用；但 <strong>push 的时候发生的 borrow 行为</strong>：编译失败。</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">first</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>遍历 vector，并修改其中的值：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">57</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">v</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">i</span> <span class="o">+=</span> <span class="mi">50</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>如果一个 vector 中需要存不同类型的值，可以利用 Enum 类型来实现：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">SpreadsheetCell</span> <span class="p">{</span>
        <span class="nf">Int</span><span class="p">(</span><span class="nb">i32</span><span class="p">),</span>
        <span class="nf">Float</span><span class="p">(</span><span class="nb">f64</span><span class="p">),</span>
        <span class="nf">Text</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">row</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="nn">SpreadsheetCell</span><span class="p">::</span><span class="nf">Int</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
        <span class="nn">SpreadsheetCell</span><span class="p">::</span><span class="nf">Text</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"blue"</span><span class="p">)),</span>
        <span class="nn">SpreadsheetCell</span><span class="p">::</span><span class="nf">Float</span><span class="p">(</span><span class="mf">10.12</span><span class="p">),</span>
    <span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>总之，Rust 必须在编译期确定 vector 中的数据的类型。</p><h3 id="slices"><span class="mr-2">slices</span><a href="#slices" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>slice（<code class="language-plaintext highlighter-rouge">[T]</code>）是 array 或 vector 中的一部分；可能是 array，也可能是 vector，总之是一段<strong>连续</strong>的数据的<a href="#references">引用</a>。</p><p>最后再说一下数组的 move</p><p>数组（或 vector）中的元素是不能被 move 的：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="c1">// Build a vector of the strings "101", "102", ... "105"</span>
<span class="k">let</span> <span class="k">mut</span> <span class="n">v</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">101</span><span class="o">..</span><span class="mi">106</span> <span class="p">{</span>
<span class="n">v</span><span class="nf">.push</span><span class="p">(</span><span class="n">i</span><span class="nf">.to_string</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// 错：Pull out random elements from the vector.</span>
<span class="k">let</span> <span class="n">third</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// error: Cannot move out of index of Vec</span>
<span class="k">let</span> <span class="n">fifth</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="c1">// here too</span>
</pre></table></code></div></div><p>如果要对数组（或 vector）中的元素做 move，需要专门的函数，例如：<code class="language-plaintext highlighter-rouge">pop</code>、<code class="language-plaintext highlighter-rouge">swap_remove</code>、<code class="language-plaintext highlighter-rouge">std::mem::replace</code>……</p><p>另外，把数组（或 vector）中的元素 move 出来也叫做 <strong>consume</strong> （消费）。例如，对 vector 中的所有元素进行「消费」：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="s">"aaa"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"bbb"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="s">"ccc"</span><span class="nf">.to_string</span><span class="p">()];</span>

<span class="k">for</span> <span class="k">mut</span> <span class="n">s</span> <span class="k">in</span> <span class="n">v</span> <span class="p">{</span>
<span class="n">s</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'!'</span><span class="p">);</span>
<span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的循环中，把 <code class="language-plaintext highlighter-rouge">v</code> 中的元素逐个 <strong>move</strong> 给 s，每次 s 拥有 v 的元素，并进行操作。</p><p>最后看一个技巧：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// 数组中元素中有 Option</span>
<span class="k">struct</span> <span class="n">Person</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">birth</span><span class="p">:</span> <span class="nb">i32</span>
<span class="p">}</span>

<span class="k">let</span> <span class="k">mut</span> <span class="n">composers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">composers</span><span class="nf">.push</span><span class="p">(</span><span class="n">Person</span> <span class="p">{</span> <span class="n">name</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="s">"Palestrina"</span><span class="nf">.to_string</span><span class="p">()),</span>
<span class="n">birth</span><span class="p">:</span> <span class="mi">1525</span> <span class="p">});</span>

<span class="c1">// 用 take 方法把 Option 的值 move 出来，而数组中留下一个 None</span>
<span class="k">let</span> <span class="n">first_name</span> <span class="o">=</span> <span class="n">composers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="py">.name</span><span class="nf">.take</span><span class="p">();</span>
</pre></table></code></div></div><h3 id="hash-map"><span class="mr-2">hash map</span><a href="#hash-map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Rust 中使用 std::collections::HashMap 来表示 1 对 1 的关系。<li>Rust 的 Map，所有的 key 必须为相同的类型。所有的 value 必须为相同的类型。</ul><hr /><p>创建一个 map 来记录 2 个队伍的分数：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">scores</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="n">scores</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">),</span> <span class="mi">10</span><span class="p">);</span>
    <span class="n">scores</span><span class="nf">.insert</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Yellow"</span><span class="p">),</span> <span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>利用 vector 的 zip 方法在初始化时创建 HashMap：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">teams</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">),</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Yellow"</span><span class="p">)];</span>
    <span class="k">let</span> <span class="n">initial_scores</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">scores</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">teams</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">initial_scores</span><span class="nf">.iter</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>Hash Map 会对其中的值有 ownership。下面的例子中，在执行了 map.insert 以后，field_name 和 field_value 失去对原先值的 ownership：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">field_name</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Favorite color"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">field_value</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">map</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">map</span><span class="nf">.insert</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">field_value</span><span class="p">);</span> <span class="c1">// 之后 field_name 和 field_value 失去对原先值的 ownership</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>拿到 HaspMap 中的值：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">team_name</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">score</span> <span class="o">=</span> <span class="n">scores</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">team_name</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>这里的 score 是一个 Some(&amp;10)，也就是说，是一个 Option&lt;&amp;V&gt;；如果值不存在，返回 None。</p><hr /><p>遍历 HashMap：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">scores</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}: {}"</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>利用 entry 方法和 or_insert 来实现只有当 key 不存在时才 insert 新值：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">scores</span><span class="nf">.entry</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Blue"</span><span class="p">))</span><span class="nf">.or_insert</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="string"><span class="mr-2">String</span><a href="#string" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>String 特性</p><ul><li>UTF-8 编码<li>growable<li>mutable</ul><hr /><p>新建 String</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="c1">// 新建</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"initial contents"</span><span class="nf">.to_string</span><span class="p">();</span> <span class="c1">// 带初始值的新建</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"initial contents"</span><span class="p">);</span> <span class="c1">// 和上面等价</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>push_str 和 push</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"foo"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="s">"bar"</span><span class="p">;</span>
    <span class="n">s1</span><span class="nf">.push_str</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="c1">// push_str 把一个 string slice 加在后面。push_str 不需要 s2 的 ownership</span>

    <span class="n">s</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'l'</span><span class="p">);</span> <span class="c1">// push 用来添加单个字符在后面</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><ul><li>用 + 号连结</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Hello, "</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"world!"</span><span class="p">);</span>

    <span class="c1">// s1 会被 move，失去「所有权」</span>
    <span class="k">let</span> <span class="n">s3</span> <span class="o">=</span> <span class="n">s1</span> <span class="o">+</span> <span class="o">&amp;</span><span class="n">s2</span><span class="p">;</span> <span class="c1">// Note s1 has been moved here and can no longer be used</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>复杂的字符串拼接用 format!</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"tic"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"tac"</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">s3</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"toe"</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nd">format!</span><span class="p">(</span><span class="s">"{}-{}-{}"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">s3</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>支持 == 和 !=<ul><li>字符串内容（存储在内存中的字符串内容）是否相等的比较<ul><li>例如：”th\u{e9}” 和 “the\u{301}” 是不相等的，尽管它们显示出来都是法文的 thé，但它们内存中的字符串内容不同</ul></ul><li>Rust 保证 String 中的字符必须是有效的 UTF-8 编码的字符<ul><li>当真的要处理无效的 UTF-8 编码的时候，需要使用其他的类型（&amp;Path，OsString 等等），而不能使用 String 类型</ul></ul><h3 id="string-slice"><span class="mr-2">string slice</span><a href="#string-slice" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>slice 允许你引用 collection 中一段连续的元素序列，而不用引用整个 collection<ul><li>除了「引用」之外，slice 也不拥有数据的 ownership</ul></ul><p>例如，引用一个整数数组中的一部分：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

    <span class="k">let</span> <span class="n">slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>注意：在编译期间不知道 String 类型的 size；而 &amp;str 的 size 在编译期间已知</p></blockquote><ul><li>Rust 专门有一个 string slice（&amp;str）类型来表达 string literals：a reference to part of a String</ul><p>举个例子：</p><p>需要写一个函数获取字符串的第一个单词。函数入参可以是一个对 String 类型的引用（&amp;String）。但返回值是什么呢？</p><p>这里返回值可以使用 string slice（&amp;str）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">first_word</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_bytes</span><span class="p">();</span> <span class="c1">// 把 String 转换为 byte 数组</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item</span><span class="p">)</span> <span class="k">in</span> <span class="n">bytes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">item</span> <span class="o">==</span> <span class="sc">b' '</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="o">..</span><span class="p">]</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>但在处理字符串时，尽量不要牵涉到 <strong>byte</strong> 操作，而是要尽量用<strong>字符</strong>相关的操作<ul><li>因为 Rust 中的字符是 UTF-8 编码，一个 UTF-8 编码的字符有几个 bytes 是不确定的。而且也是因为这个「不确定」，要获取 String 的某个 UTF-8 字符，只能是遍历整个 String：</ul></ul><p>利用 chars 来遍历字段串的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">c</span> <span class="k">in</span> <span class="s">"您好"</span><span class="nf">.chars</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>String 上的 slice range 语法是 byte 级别的操作。如果尝试从一个多字节字符的中间位置创建字符串 slice，则程序将会因错误而退出。</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello world"</span><span class="p">);</span>

    <span class="c1">// 该例子是 ASCII 字符集上的 String，所以不会出错</span>
    <span class="k">let</span> <span class="n">hello</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">world</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="o">..</span><span class="mi">11</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>其他一些关于 &amp;str 的要点：</p><ul><li>“您好”.len() 返回的是 <strong>byte</strong> 数，而不是字符数。”您好”.chars().count() 才返回的是<strong>字符数</strong><li>&amp;str 不能被修改；所以如果要在运行时修改一个字符串，需要使用 String<ul><li>不过 make_ascii_uppercase 和 make_ascii_lowercase 这 2 个方法是例外，它们会修改 &amp;mut str</ul><li>从 String 中拿到对应的 &amp;str。例如，要在一个 String 上进行 match 可以这样：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"Canada"</span><span class="p">);</span>

    <span class="k">match</span> <span class="n">s</span><span class="nf">.as_str</span><span class="p">()</span> <span class="p">{</span>
        <span class="s">"Japan"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Match"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Un-Match"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="struct"><span class="mr-2">struct</span><a href="#struct" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust 中利用 <a href="#struct">struct</a> 实现了一种把不同的数据聚合在一起的方法。这种方法主要使用在需要不同数据类型需要同时存在在一起的场景。</p><p>以此向对应的，如果需要把多种数据类型聚合在一起，但不需要它们同时出现，可以使用 <a href="#enum">enum</a> 。</p><p>定义一个 struct ，然后定义一个返回 struct 的方法</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
        <span class="n">active</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">build_user</span><span class="p">(</span><span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span> <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">User</span> <span class="p">{</span>
            <span class="c1">// 变量名和结构体字段名相同时，可以使用初始化简写</span>
            <span class="n">email</span><span class="p">,</span>
            <span class="c1">// 变量名和结构体字段名相同时，可以使用初始化简写</span>
            <span class="n">username</span><span class="p">,</span>
            <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
            <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>结构体的上下文中可以定义方法（method）:</p><ul><li>method 的第一个参数总是 self，它代表调用该方法的结构体实例</ul><p>下面的例子给 Rectangle 这个结构体定义并实现了 area 和 can_hold（注意 <strong>impl</strong> 关键字的使用）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="n">width</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">height</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Rectangle</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">area</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">*</span> <span class="k">self</span><span class="py">.height</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Rectangle</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.width</span> <span class="o">&gt;</span> <span class="n">other</span><span class="py">.width</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.height</span> <span class="o">&gt;</span> <span class="n">other</span><span class="py">.height</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rect1</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">width</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">50</span> <span class="p">};</span>
    <span class="k">let</span> <span class="n">rect2</span> <span class="o">=</span> <span class="n">Rectangle</span> <span class="p">{</span> <span class="n">width</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="mi">40</span> <span class="p">};</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"The area of the rectangle is {} square pixels."</span><span class="p">,</span> <span class="n">rect1</span><span class="nf">.area</span><span class="p">());</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Can rect1 hold rect2? {}"</span><span class="p">,</span> <span class="n">rect1</span><span class="nf">.can_hold</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rect2</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>一般来说 method 的第一个参数可以是 &amp;self 或者 &amp;mut self</p></blockquote><ul><li><strong>tuple structs</strong>：tuple structs 的用法和普通 struct 类似，但 tuple structs 没有具体的字段名，只有字段的类型。简单点说，就是定义一个有类型名字的 tuple 类型。给个例子：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="cd">/// 定义一个颜色类型，其包含 3 个三元色的值</span>
<span class="k">struct</span> <span class="nf">Color</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">);</span>
</pre></table></code></div></div><ul><li><strong>struct update</strong>。如下例子：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">active</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="c1">// 注意：这里的 username 是 String 类型，一旦发生 move，整个 struct 也不能再被使用</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 先定义 user1</span>
    <span class="k">let</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone@example.com"</span><span class="p">),</span>
        <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone123"</span><span class="p">),</span>
        <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// 然后通过更新的方式来定义 user2</span>
    <span class="c1">// 注意：这里发生了一次 String 类型 username 的 move，之后不能再使用 user1</span>
    <span class="k">let</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">active</span><span class="p">:</span> <span class="n">user1</span><span class="py">.active</span><span class="p">,</span>
        <span class="n">username</span><span class="p">:</span> <span class="n">user1</span><span class="py">.username</span><span class="p">,</span>
        <span class="c1">// 实际上 user1 和 user2 只有 email 这 1 个字段不同</span>
        <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"another@example.com"</span><span class="p">),</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="n">user1</span><span class="py">.sign_in_count</span><span class="p">,</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>上面的例子也可以采用<strong>简约写法</strong>：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">struct</span> <span class="n">User</span> <span class="p">{</span>
    <span class="n">active</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">sign_in_count</span><span class="p">:</span> <span class="nb">u64</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 先定义 user1</span>
    <span class="k">let</span> <span class="n">user1</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
        <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone@example.com"</span><span class="p">),</span>
        <span class="n">username</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"someone123"</span><span class="p">),</span>
        <span class="n">active</span><span class="p">:</span> <span class="k">true</span><span class="p">,</span>
        <span class="n">sign_in_count</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">};</span>

    <span class="c1">// 注意：这里发生了一次 String 类型 username 的 move，之后不能再使用 user1</span>
    <span class="k">let</span> <span class="n">user2</span> <span class="o">=</span> <span class="n">User</span> <span class="p">{</span>
        <span class="c1">// 实际上 user1 和 user2 只有 email 这 1 个字段不同，采用了 ..user1 这种简约写法</span>
        <span class="n">email</span><span class="p">:</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"another@example.com"</span><span class="p">),</span>
        <span class="o">..</span><span class="n">user1</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>注意：struct 的生命周期请参考：<a href="#结构体的生命周期注解">结构体的生命周期注解</a></p></blockquote><h3 id="type-associated-functions"><span class="mr-2">type-associated functions</span><a href="#type-associated-functions" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>impl 的实现中，有时候不是针对单个 struct 实例的，而是针对整个类型，所以参数列表中没有 self 参数。</p><p>把参数中没有 self 的 methods 叫做 type-associated functions。例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">impl</span> <span class="n">Queue</span> <span class="p">{</span>
  <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Queue</span> <span class="p">{</span>
    <span class="n">Queue</span> <span class="p">{</span> <span class="n">older</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="n">younger</span><span class="p">:</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span> <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>对应的使用方法如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">let</span> <span class="k">mut</span> <span class="n">q</span> <span class="o">=</span> <span class="nn">Queue</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
<span class="n">q</span><span class="nf">.push</span><span class="p">(</span><span class="sc">'*'</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="enum"><span class="mr-2">enum</span><a href="#enum" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust 的枚举（enum）中的「成员」可以<strong>存储各种类型</strong>。例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
        <span class="c1">// 普通「枚举成员」，没有嵌入任何其他类型</span>
        <span class="n">Quit</span><span class="p">,</span>
        <span class="c1">// 存储了一个匿名 struct 的「枚举成员」</span>
        <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
        <span class="c1">// 存储一个 String 类型的「枚举成员」</span>
        <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
        <span class="c1">// 存储了 3 个 i32 的「枚举成员」</span>
        <span class="nf">ChangeColor</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Rust 还可以在枚举上定义方法（类似 struct）。例如针对上面定义的 Message 枚举类型定义了一个 call 方法：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
        <span class="n">Quit</span><span class="p">,</span>
        <span class="n">Move</span> <span class="p">{</span> <span class="n">x</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">i32</span> <span class="p">},</span>
        <span class="nf">Write</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
        <span class="nf">ChangeColor</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">,</span> <span class="nb">i32</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="n">Message</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">call</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 在这里定义方法体</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">Message</span><span class="p">::</span><span class="nf">Write</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
    <span class="n">m</span><span class="nf">.call</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>标准库中的 Option 就是一个枚举类型，其定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="nb">None</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="patterns"><span class="mr-2">Patterns</span><a href="#patterns" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>再重点介绍一下 Patterns。</p><p>首先明确一点：相对于 Expressions <strong>产生</strong> values；Patterns <strong>消费</strong> values。</p><p>Patterns 的作用对象可以是：enum，struct 或 tuple。</p><p>Patterns 内部有 identifiers 的话，这些 identifiers 会成为局部变量。这些 identifiers 的 values 会被 copy 或 move 到这些局部变量。</p><p>用一个例子来说明 move：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">match</span> <span class="n">account</span> <span class="p">{</span>
    <span class="n">Account</span> <span class="p">{</span><span class="n">name</span><span class="p">,</span> <span class="n">language</span><span class="p">,</span> <span class="o">..</span><span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="n">ui</span><span class="nf">.greet</span><span class="p">(</span> <span class="o">&amp;</span> <span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span> <span class="n">language</span><span class="p">);</span>
        <span class="n">ui</span><span class="nf">.show_setting</span><span class="p">(</span> <span class="o">&amp;</span> <span class="n">account</span><span class="p">);</span> <span class="c1">// error: borrow of moved value: `account`</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的例子中，<code class="language-plaintext highlighter-rouge">account.name</code> 和 <code class="language-plaintext highlighter-rouge">account.language</code> 已经被 move 到 2 个局部变量中，account 然后就被 drop 掉了。所以，之后不能再 borrow account。</p><p>除了 copy 和 move，也可以使用 <code class="language-plaintext highlighter-rouge">ref</code> 关键字，表示 borrow（不对 value 进行<strong>消费</strong>，只是 borrow）。例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">match</span> <span class="n">account</span> <span class="p">{</span>
    <span class="n">Account</span> <span class="p">{</span> <span class="k">ref</span> <span class="n">name</span><span class="p">,</span> <span class="k">ref</span> <span class="n">language</span><span class="p">,</span> <span class="o">..</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
        <span class="n">ui</span><span class="nf">.greet</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">language</span><span class="p">);</span> <span class="c1">// 只 borrow，不消费</span>
        <span class="n">ui</span><span class="nf">.show_setting</span><span class="p">(</span> <span class="o">&amp;</span> <span class="n">account</span><span class="p">);</span> <span class="c1">// ok</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>最后，看一个 Patterns 的应用 <code class="language-plaintext highlighter-rouge">while let</code> 表达式：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">//gfg is a variable</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">gfg</span> <span class="o">=</span> <span class="s">"Printing Geeks for Geeks using while let"</span><span class="nf">.chars</span><span class="p">();</span>
    <span class="c1">// let pattern = expr（如果表达式能和这个 pattern 匹配，执行循环）</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="n">gfg</span><span class="nf">.next</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">//print is a statement that is used to print characters in one line</span>
        <span class="nd">print!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="match"><span class="mr-2">match</span><a href="#match" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>match 关键字后跟一个表达式<li>执行时，根据这个表达式计算出来的值，按顺序进行匹配，进入匹配成功的分支<li>match 的每个分支由 2 部分组成<ul><li>模式：用来匹配是否进入该分支<li>代码：进入该分支后需要执行的代码；<ul><li>而且每个分支的执行代码有一个结果值，被匹配到的分支的结果值就是整个 match 表达式的值</ul></ul></ul><p>枚举的成员是 struct 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">Protection</span> <span class="p">{</span>
    <span class="c1">// 枚举成员是一个匿名的 struct</span>
    <span class="n">Secure</span> <span class="p">{</span> <span class="n">version</span><span class="p">:</span> <span class="nb">u64</span> <span class="p">},</span>
    <span class="n">Insecure</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">prot</span><span class="p">:</span> <span class="n">Protection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">prot</span> <span class="p">{</span>
        <span class="c1">// 匹配的时候，匿名 struct 的值：{version}</span>
        <span class="nn">Protection</span><span class="p">::</span><span class="n">Secure</span> <span class="p">{</span> <span class="n">version</span> <span class="p">}</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Hacker-safe thanks to protocol v{}"</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nn">Protection</span><span class="p">::</span><span class="n">Insecure</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Come on in"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">process</span><span class="p">(</span><span class="nn">Protection</span><span class="p">::</span><span class="n">Secure</span> <span class="p">{</span> <span class="n">version</span><span class="p">:</span> <span class="mi">2</span> <span class="p">})</span>
<span class="p">}</span>
</pre></table></code></div></div><p>问题：如果 match 的表达式是一个「引用」，那么 match 匹配的值是否也是「引用」？看一个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">pub</span> <span class="k">enum</span> <span class="n">Protection</span> <span class="p">{</span>
    <span class="c1">// 枚举成员存储了一个 SecureVersion 类型的值</span>
    <span class="nf">Secure</span><span class="p">(</span><span class="n">SecureVersion</span><span class="p">),</span>
    <span class="n">Insecure</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">SecureVersion</span> <span class="p">{</span>
    <span class="n">V1</span><span class="p">,</span>
    <span class="n">V2</span><span class="p">,</span>
    <span class="n">V2_1</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">prot</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Protection</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">prot</span> <span class="p">{</span>
        <span class="c1">// 答案：这里的 version 是一个引用：&amp;SecureVersion</span>
        <span class="nn">Protection</span><span class="p">::</span><span class="nf">Secure</span><span class="p">(</span><span class="n">version</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Hacker-safe thanks to protocol {version:?}"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nn">Protection</span><span class="p">::</span><span class="n">Insecure</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Come on in"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="module"><span class="mr-2">module</span><a href="#module" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>基本概念：</p><ul><li>Module：对代码进行组织的单元（逻辑上把对代码分成不同的部分，便于管理）<li>Crate：独立的可编译单元，可以编译为「库」，或者是「可执行文件」<li>Package：类似项目（或者工程）的概念，一个 Package 只能包含一个 Cargo.toml 文件<ul><li>一个 Package 只能包含一个「库」；但一个 Package 可以包含多个「可执行文件」<ul><li>这里的「库」和「可执行文件」就是上面提到的 Crate：独立的可编译单元</ul></ul></ul><p>下面给一个典型的 Package（项目）的目录结构：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nb">.</span>
├── Cargo.toml
├── Cargo.lock
├── src
│   ├── main.rs
│   ├── lib.rs
│   └── bin
│       └── main1.rs
│       └── main2.rs
├── tests
│   └── some_integration_tests.rs
├── benches
│   └── simple_bench.rs
└── examples
    └── simple_example.rs
</pre></table></code></div></div><p>几个关键词的作用：</p><ul><li>mod<li>pub<li>super<li>use</ul><p>另外就是下面 3 个 cargo 命令的用法：</p><ul><li>cargo new comm –lib<li>cargo fmt<li>cargo test<li>cargo doc –no-deps –open<ul><li>不生成依赖的文档</ul></ul><h3 id="attribute"><span class="mr-2">Attribute</span><a href="#attribute" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>在 Rust 中，Attributes 类似 Java 的注解（annotations），或者 C/C++ 中的 #ifndef 这种给编译器使用的属性<ul><li>Attributes 都是给编译器使用的</ul><li>注解在 Rust 的各种 items 上<ul><li>例如：注解在 module 上，并对整个 module 生效（标注在 module 上：#[cfg]，#[allow]）<li>Rust 中 item 的类型具体有：<ul><li>module<li>extern crate 声明<li>use 声明<li>函数定义<li>类型定义<li>结构体定义<li>枚举定义<li>联合体定义<li>常量项<li>静态项<li>trait 定义<li>实现<li>外部块</ul></ul><li>crate 上：标注在整个 crate 的最前面，需要使用 #![cfg] （多一个 ! 表示作用在整个 crate 上）<li>Rust 中常用的 Attributes 有 4 大类：<ul><li>Built-in attributes（内建属性）：下面会有些例子<li>Macro attributes（宏属性）：略<li>Derive macro helper attributes（派生宏辅助属性）<li>Tool attributes（工具属性）：略</ul></ul><p>一些常用的 Attributes：</p><ul><li>#[allow]：显示的关闭编译 warning。例如：#[allow(non_camel_case_types)]<li>#[cfg]：用于设置编译选项，具体配置项可参考说明。例如：#[cfg(test)]（用于标注只在测试时生效的代码）<li>#[test]：测试相关<li>#[doc]：自动生成代码文档<li>#[derive]：derive 属性会在使用 derive 语法标记的类型上生成对应 trait 的默认实现的代码。给 2 个例子：<ul><li>#[derive(Debug)]：只要给 struct 和 enum 加上这个 derive 属性，就可以在 println! 里面直接使用 {:?} 或者 {:#?}<li>#[derive(Copy, Clone)]：Copy 和 Clone</ul></ul><h2 id="error"><span class="mr-2">error</span><a href="#error" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>开发人员作为不同身份时，可以利用不同的方式来应对异常<ul><li>作为库的开发人员<ul><li>定义这个库的专用异常类型，通过这个专用异常类型告诉库的使用者，当遇到不同的异常时，需要进行相应的处理<ul><li>举个例子，一个用于查询 MySQL 的库；当执行 SQL 语句失败时，需要告诉库的使用者失败原因；而库的使用者根据失败原因做不同的动作：可重试的进行重试，不可重试的直接通知最终用户本次请求失败等等</ul><li>而且大多数场景，库本身可以不直接打印日志（而是由库的使用者来决定库相关日志的配置，例如日志级别，日志文件位置）</ul><li>作为应用（在线服务）的开发人员<ul><li>不可恢复异常；对一个在线服务，开发人员可以考虑把「不可恢复异常」透传到最外层，在最外层完成下列工作：<ul><li>记录上下文（统计，排查，报警等目的）<li>结束当前请求<li>同时返回给最终用户一个友好的提示</ul><li>可恢复异常：这里的「可恢复异常」可以理解为程序正常执行的多种可能的分支中的一个逻辑分支<ul><li>开发人员的工作：把代码流程转入对应的逻辑分支（如有必要可打印日志，例如用于统计）</ul></ul></ul></ul><p>要达到以上目标，一种程序设计语言中，需要提供以下功能：</p><ul><li>函数调用除了返回正常结果，也可以抛出异常<li>异常需要带必要的信息：异常码，异常信息，异常时的上下文信息（调用堆栈，代码行号等）<ul><li>尽可能提供模块级别（Module Level）的异常类，而不是全局（Crate Level）的异常类<li>相同的底层异常（例如一个 IO 异常）抛出时，最好能区分该异常抛出时的上下文信息</ul><li>便捷的把异常透传到最外层<li>捕捉到异常后，便捷的根据异常具体的信息，执行不同的代码逻辑<li>通过日志门面库（类似 Java 的 slf4j）和日志实现库（类似 Java 的 log4j，logback）配合，来灵活的记录日志</ul><p>而在 Rust 中，异常处理相关的语法有：</p><ul><li>panic!<li>RESULT</ul><h3 id="panic"><span class="mr-2">panic</span><a href="#panic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>其实对在线服务来说，panic 其实不怎么用。使用 panic 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">panic!</span><span class="p">(</span><span class="s">"crash and burn"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>发生 panic 后，Rust 会 unwind stack 后继续执行。但有 2 个例外的情况 Rust 不会做 unwind：<ul><li>当遇到一个 panic 后，Rust 在做 drop 时，又触发了一个新的 panic；此时会干掉整个进程！<li>编译时带上 -C panic=abort 选项，当遇到一个 panic 后，直接干掉整个进程！</ul><li>panic 是线程级别的。单个线程里面 panic 了，并不会影响其他线程的正常执行<li>也可以 catch 住 panic，这样线程可以继续执行（参考标准库的：std::panic::catch_unwind）</ul><h3 id="result"><span class="mr-2">Result</span><a href="#result" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Rust 使用一个标准库定义的 Enum 类型 Result 来表达函数的正常返回和异常：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="nf">Err</span><span class="p">(</span><span class="n">E</span><span class="p">),</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>用 enum 的潜台词就是函数返回时，要么返回一个正常的结果，要么遇到一个可恢复异常。</p></blockquote><hr /><p>分别对正常结果，和异常处理的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">match</span> <span class="nf">get_weather</span><span class="p">(</span><span class="n">hometown</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">report</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nf">display_weather</span><span class="p">(</span><span class="n">hometown</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">report</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"error querying the weather: {}"</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
            <span class="nf">schedule_weather_retry</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>异常类型忽略的写法：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="c1">// 返回一个 () 或遇到一个异常</span>
<span class="k">fn</span> <span class="nf">remove_file</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Path</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{}</span>
</pre></table></code></div></div><p>这种写法用来表示这个 Module 中定义了 Result 类型的 <strong>type alias</strong>，省得到处都要写异常的具体类型（一般来说，某个 Module 中的异常都是相同类型的异常）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">result</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><hr /><p>Result 配合 unwrap 的使用：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// unwrap()：成功的话，从 Result&lt;T&gt; 中拿到 T，失败的话，panic</span>
    <span class="c1">// 不推荐使用，因为一般来说，不应该使用 panic</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// 一般推荐的做法有 2 种：</span>
    <span class="c1">// 1) 使用 unwrap_or_else：成功拿到 T；失败的话，通过执行一个 closure 得到 T</span>
    <span class="c1">// 2) 或者把异常传递到调用者</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Result 配合 expect 的使用：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="nf">.expect</span><span class="p">(</span><span class="s">"Failed to open hello.txt"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>一个把异常传递到调用者的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="k">match</span> <span class="n">f</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">file</span><span class="p">,</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="c1">// 第一个可能传递异常的位置</span>
    <span class="p">};</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">match</span> <span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">),</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nf">Err</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="c1">// 第二个可能传递异常的位置</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面的例子，可以利用 ? 进行简化（功能完全相同，但代码更整洁）</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">f</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="nf">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><p>还可以利用链式写法进一步简化：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">io</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="n">Read</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">read_username_from_file</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">s</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="o">?</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">s</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="nf">Ok</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="p">}</span>
</pre></table></code></div></div><p><strong>注意：</strong> 一个方法如果不返回 Result 类型，就不能使用 ? 来进行简化。</p><h3 id="实现-error-trait"><span class="mr-2">实现 Error Trait</span><a href="#实现-error-trait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>在很多场景里面，使用 Rust 时，目前最好的实践还是自己实现一个 Error 类型（枚举或结构），也就是实现标准库里面的 Error Trait：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">trait</span> <span class="n">Error</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">Display</span> <span class="p">{</span>
    <span class="cd">/// The lower-level source of this error, if any.</span>
    <span class="cd">/// dyn Error 是一个 trait object</span>
    <span class="cd">/// trait object 作为 Rust 中的多态，这样既可以无需关注异常的具体类型，也可以通过 source 获取异常时具体的调用链</span>
    <span class="cd">/// 如果该错误类型中包含了底层的错误 Err，那么 source 方法应该返回 Some(err), 如果没有返回 None。不重写则默认为 None</span>
    <span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="k">dyn</span> <span class="n">Error</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nb">None</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>一个实现了 source，并利用 source 打印异常堆栈的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// A new error type, wrapping a sqlx::Error</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">StoreTokenError</span><span class="p">(</span><span class="nn">sqlx</span><span class="p">::</span><span class="n">Error</span><span class="p">);</span>

<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="k">for</span> <span class="n">StoreTokenError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">source</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="p">(</span><span class="k">dyn</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span> <span class="o">+</span> <span class="k">'static</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// The compiler transparently casts `&amp;sqlx::Error` into a `&amp;dyn Error`</span>
        <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">error_chain_fmt</span><span class="p">(</span>
    <span class="n">e</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">error</span><span class="p">::</span><span class="n">Error</span><span class="p">,</span>
    <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
    <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"{}</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">current</span> <span class="o">=</span> <span class="n">e</span><span class="nf">.source</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cause</span><span class="p">)</span> <span class="o">=</span> <span class="n">current</span> <span class="p">{</span>
        <span class="nd">writeln!</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">"Caused by:</span><span class="se">\n\t</span><span class="s">{}"</span><span class="p">,</span> <span class="n">cause</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">cause</span><span class="nf">.source</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span> <span class="k">for</span> <span class="n">StoreTokenError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">fmt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Formatter</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="nb">Result</span> <span class="p">{</span>
        <span class="nf">error_chain_fmt</span><span class="p">(</span><span class="k">self</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>另外的惯用法是，在一个 Module 中定义一个枚举错误类型来封装多种异常类型：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">SubscribeError</span> <span class="p">{</span>
    <span class="nf">ValidationError</span><span class="p">(</span><span class="nb">String</span><span class="p">),</span>
    <span class="nf">DatabaseError</span><span class="p">(</span><span class="nn">sqlx</span><span class="p">::</span><span class="n">Error</span><span class="p">),</span>
    <span class="nf">StoreTokenError</span><span class="p">(</span><span class="n">StoreTokenError</span><span class="p">),</span>
    <span class="nf">SendEmailError</span><span class="p">(</span><span class="nn">reqwest</span><span class="p">::</span><span class="n">Error</span><span class="p">),</span>
<span class="p">}</span>
</pre></table></code></div></div><p>然后用 From 来把其他错误类型转换为这个 Module 专用的错误类型。例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="nn">sqlx</span><span class="p">::</span><span class="n">Error</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">SubscribeError</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="nn">sqlx</span><span class="p">::</span><span class="n">Error</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="nf">DatabaseError</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>尽管通过以上代码可以实现一个 Error Trait，但还是太繁琐了。现在流行的做法是用库来自动生成 Error 类型，例如：</p><ul><li><strong>thiserror</strong><li><strong>snafu</strong></ul><p>具体用法可以参考这些库的文档。</p><h3 id="日志"><span class="mr-2">日志</span><a href="#日志" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>Rust 比较流行的「日志门面库」是：log 库（类似 Java 的 slf4j）</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="k">log</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
</pre></table></code></div></div><ul><li>真正输出日志，除了「日志门面库」之外，还需要「日志库」。这里重点介绍一下 <strong>tracing</strong> 库<li>由于很多场景，记录日志时，需要区分不同的「执行流」，并能在日志中查看属于某个「执行流」的所有日志。tracing 库引入了 <strong>span</strong> 概念<ul><li>例如：在服务端，按某一次用户请求来记录日志，然后可以在服务端日志里面查看这次请求的执行流程。那么服务端对这次请求处理的开始到结束就是一个 <strong>span</strong><li>也就是说，可以利用 tracing 库来跟踪<strong>「逻辑上下文」</strong></ul><li>tracing 使用「结构化数据」来记录「逻辑上下文」的信息（一般来说就是 kv 对）。然后在最后输出的每条日志中，同时输出这个 kv 对的值。例如如下输出（每条日志都输出了每次请求的 client.addr 的值，用来标明每条日志的「逻辑上下文」）：</ul><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>DEBUG server<span class="o">{</span>client.addr<span class="o">=</span>106.42.126.8:56975<span class="o">}</span>: accepted connection
DEBUG server<span class="o">{</span>client.addr<span class="o">=</span>82.5.70.2:53121<span class="o">}</span>: closing connection
DEBUG server<span class="o">{</span>client.addr<span class="o">=</span>89.56.1.12:55601<span class="o">}</span> request<span class="o">{</span><span class="nv">path</span><span class="o">=</span><span class="s2">"/posts/tracing"</span> <span class="nv">method</span><span class="o">=</span>GET<span class="o">}</span>: received request
DEBUG server<span class="o">{</span>client.addr<span class="o">=</span>111.103.8.9:49123<span class="o">}</span>: accepted connection
DEBUG server<span class="o">{</span>client.addr<span class="o">=</span>106.42.126.8:56975<span class="o">}</span> request<span class="o">{</span><span class="nv">path</span><span class="o">=</span><span class="s2">"/"</span> <span class="nv">method</span><span class="o">=</span>PUT<span class="o">}</span>: received request
DEBUG server<span class="o">{</span>client.addr<span class="o">=</span>113.12.37.105:51342<span class="o">}</span>: accepted connection
 WARN server<span class="o">{</span>client.addr<span class="o">=</span>106.42.126.8:56975<span class="o">}</span> request<span class="o">{</span><span class="nv">path</span><span class="o">=</span><span class="s2">"/"</span> <span class="nv">method</span><span class="o">=</span>PUT<span class="o">}</span>: invalid request headers
TRACE server<span class="o">{</span>client.addr<span class="o">=</span>106.42.126.8:56975<span class="o">}</span> request<span class="o">{</span><span class="nv">path</span><span class="o">=</span><span class="s2">"/"</span> <span class="nv">method</span><span class="o">=</span>PUT<span class="o">}</span>: closing connection
</pre></table></code></div></div><p>最后给一个异步代码使用 tracing 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// 对每个用户请求 spawn 一个异步任务</span>
    <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">socket</span><span class="nf">.as_raw_fd</span><span class="p">();</span>

        <span class="k">if</span> <span class="k">let</span> <span class="nf">Err</span><span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="nf">process</span><span class="p">(</span><span class="n">socket</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cli</span><span class="p">)</span><span class="k">.await</span> <span class="p">{</span>
            <span class="nd">error!</span><span class="p">(</span><span class="s">"this client has an error, disconnect it {}!"</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">});</span>

    <span class="c1">// 然后利用 tracing 的 instrument 宏，指明用于「逻辑上下文」的数据为 fd</span>
    <span class="nd">#[instrument(skip(socket,</span> <span class="nd">cli))]</span>
    <span class="k">pub</span> <span class="k">async</span> <span class="k">fn</span> <span class="nf">process</span><span class="p">(</span><span class="n">socket</span><span class="p">:</span> <span class="n">TcpStream</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="nb">i32</span><span class="p">,</span> <span class="n">cli</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nn">reqwest</span><span class="p">::</span><span class="n">Client</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 最后日志输出的时候，都会带上 fd 的值作为</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"the server accepted a new client. fd is: {}"</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
        <span class="c1">// 例如这个日志输出：</span>
        <span class="c1">// 2022-04-26T08:00:28.904581Z  INFO process{fd=10}: rmr: the server accepted a new client. fd is: 10</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="traits"><span class="mr-2">traits</span><a href="#traits" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li>在 Rust 中，Trait 就类似 Java 的 Interface（接口）的作用<li>使用 trait 时必须先 use 它。但 Clone 和 Iterator 是例外，可以不导入也能用，这是因为 Clone 和 Iterator 在 standard prelude 中</ul><blockquote><p><strong>standard prelude</strong>（标准前置模块）：Rust 会把「标准前置模块」自动导入到所有 module 中；所有可以直接用，无需导入</p></blockquote><ul><li>trait 作为函数参数的例子（注意 <strong>impl</strong> 关键字的使用）：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// item 可以是实现了 Summary trait 的类型</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Breaking news! {}"</span><span class="p">,</span> <span class="n">item</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>给一个和上面 <strong>impl</strong> 等价的使用了<strong>泛型参数声明</strong>的写法：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Breaking news! {}"</span><span class="p">,</span> <span class="n">item</span><span class="nf">.summarize</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>指定多个 trait bound 的例子：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">notify</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="o">&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><p>等价：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">notify</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="k">impl</span> <span class="n">Summary</span> <span class="o">+</span> <span class="n">Display</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><ul><li>通过 where 简化的例子：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="n">some_function</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">U</span><span class="p">)</span>
    <span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="n">Display</span> <span class="o">+</span> <span class="nb">Clone</span><span class="p">,</span>
          <span class="n">U</span><span class="p">:</span> <span class="nb">Clone</span> <span class="o">+</span> <span class="n">Debug</span>
<span class="p">{}</span>
</pre></table></code></div></div><ul><li>Rust 中可以使用 trait 来实现多态（polymorphism）的效果。利用 trait 来达到多态的效果有 2 种方法：<ul><li><strong>Trait Objects</strong>：A reference to a trait type is called a trait object<ul><li>翻译：trait object 就是对一个 trait 类型的引用<li>trait object 是 fat pointer，由 2 部分组成：<ul><li>指向 value 的指针<li>执行 value 的类型的指针</ul></ul><li><strong>Generic Type Parameter</strong>：使用泛型作为函数类型参数</ul></ul><p>给一个 trait object 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">local_file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">create</span><span class="p">(</span><span class="s">"hello.txt"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>

    <span class="c1">// 函数入参 &amp;mut local_file 是一个 &amp;mut File 类型的引用</span>
    <span class="c1">// 而 say_hello 的入参定义是一个 trait object：&amp;mut dyn Write</span>
    <span class="c1">// 这里隐含了一个 Rust 的自动转换：&amp;mut File =&gt; &amp;mut dyn Write</span>
    <span class="nf">say_hello</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">local_file</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>给一个泛型作为函数类型参数的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">hash</span><span class="p">::</span><span class="n">Hash</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Debug</span><span class="p">;</span>

<span class="c1">// 这里的类型 T 必须同时是 3 个 traits 的实现：Debug，Hash，Eq</span>
<span class="k">fn</span> <span class="n">top_ten</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="n">Debug</span> <span class="o">+</span> <span class="n">Hash</span> <span class="o">+</span> <span class="nb">Eq</span><span class="o">&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{}</span>
</pre></table></code></div></div><ul><li>利用 trait 来达到多态的效果的 2 种方法的对比：<ul><li>Trait Object：<ul><li>如果一个集合中需要包含多种不同类型的元素，那么要用 trait object<li>另外，使用 trait object 可以节约编译时间（因为 trait object 是在运行时才确认指向的具体对象）；就是所谓的「dynamic dispatch」（dyn 关键字）</ul><li>Generic Type Parameter：<ul><li>泛型类型参数的运行效率更高（泛型是在编译时展开，所以运行时无额外的代价）</ul></ul></ul><hr /><p>其他一些 trait 相关的注意事项：</p><ul><li>可以给 trait 提供一个 default 实现<li>Rust 允许在任何类型实现任何 trait；也就是说，我们甚至可以在基础类型（举例： char 类型）上实现新的 trait<li>也可以在某个泛型类型上实现 trait。给个例子：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="c1">// 在 Write 这个泛型类型上实现一个 WriteHtml trait</span>
<span class="k">impl</span><span class="o">&lt;</span><span class="n">W</span><span class="p">:</span> <span class="n">Write</span><span class="o">&gt;</span> <span class="n">WriteHtml</span> <span class="k">for</span> <span class="n">W</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">write_html</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">html</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HtmlDocument</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span>
    <span class="p">{}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><strong>orphan rule</strong>：can’t implement external traits on external types<ul><li>不能给对外部类型实现外部 traits；这样 Rust 才能确保当前的这个 trait 的实现是「唯一」的（在一个 crate 内，一个 trait 不能同时有 2 个实现）<li>举个例子：在我们自己的 crate 里面不能对 <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> 实现 Display trait（标准库里面已经在 <code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> 上实现了 Display trait）</ul></ul><p>下面的小节会介绍一些常用 Traits</p><h3 id="drop"><span class="mr-2">Drop</span><a href="#drop" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>当一个 value 的 owner 失效后，Rust 会 <strong>Drop</strong> 这个 value。具体成来说可能有几种场景：<ul><li>变量的 scope 结束<li>vector 中的一个元素被删除</ul><li>通常来说，Rust 已经提供了 Drop Trait 的实现（例如 vector/标准库中的文件相关）<li>但我们也可以自己重新实现 Drop Trait。但一旦实现了 Drop Trait，就不能再实现 Copy Trait<li>另外一个值得注意的是，Drop 只会被调用一次（move 的时候其实不会调用 Drop，只有 value 真正失效时，才会调用 Drop）</ul><h3 id="sized"><span class="mr-2">Sized</span><a href="#sized" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>A sized type is one whose values all have the same size in memory<ul><li>翻译：该类型中所有的 values 的 size 必须是相同</ul><li>实现了 std::marker::Sized 这个 trait。Rust 已经都实现了，开发者不能再提供自己的实现<ul><li>所以唯一的用途就是作为类型的 bound，比如使用泛型时的 bound</ul><li>enum 也是 sized 类型：尽管 enum 中各个变量的类型可能不同，但 Rust 会按最大所需的 size 给每个变量分配空间</ul><p>尽管 Rust 中绝大多数类型是 Sized 的，但有几种类型不是 Sized：</p><ul><li>slice type str (note, <strong>without an &amp;</strong>) is unsized<li>Array slice types like [T] (again, <strong>without an &amp;</strong>)<li><strong>dyn type</strong>：the referent of a <strong>trait object</strong></ul><blockquote><p>unsized 类型不能作为函数参数，也不能直接用一个变量来 store 这个类型的值。只能通过引用或者指针来操作 unsized 类型的值</p></blockquote><h3 id="clone"><span class="mr-2">Clone</span><a href="#clone" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Clone trait 定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nb">Clone</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">clone_from</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span> <span class="o">=</span> <span class="n">source</span><span class="nf">.clone</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>Clone 必然是工作在 Sized 类型上（该类型的大小可确定）<li>大多数时候，clone_from （clone 出来源的值，并替换掉 self）使用默认实现就行了：直接用 clone 来实现</ul><h3 id="copy-1"><span class="mr-2">Copy</span><a href="#copy-1" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Rust 中，赋值时，默认的行为时 move。但可以通过实现 <strong>Copy trait</strong> （std::marker::Copy）来替换默认行为。Copy trait 定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nb">Copy</span><span class="p">:</span> <span class="nb">Clone</span> <span class="p">{}</span>
</pre></table></code></div></div><ul><li><strong>限制</strong>：实现了 Drop trait 的类型不能被 Copy<li>#[derive(Copy, Clone)] 的使用</ul><h3 id="deref-and-derefmut"><span class="mr-2">Deref and DerefMut</span><a href="#deref-and-derefmut" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Deref 和 DerefMut 主要的用途有 2 个：</p><ol><li>给自定义的类型提供类似 Rust「原生」的「解引用」操作<li><strong>deref coercions</strong>，也就是可以实现「自动的」把一个类型的「引用」转换」成另外一个类型的「引用」</ol><p>先看「解引用」，回顾一下 Rust 中的「<strong>解引用</strong>」操作符号 <code class="language-plaintext highlighter-rouge">*</code> 的用法：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="c1">// &amp; 引用就是 Rust 中的安全指针</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>通过实现 std::ops::Deref 和 std::ops::DerefMut 这 2 个 trait 来实现「自定义」类型的 <code class="language-plaintext highlighter-rouge">*</code> 「<strong>解引用</strong>」操作符号。例如 <code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code> 实现了 Deref 和 DerefMut，就可以如下使用：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="c1">// Box&lt;T&gt; 就是 Rust 中的智能指针</span>
    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Deref 和 DerefMut 这 2 个 trait 大概定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Deref</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">;</span>
    <span class="c1">// 注意：这里返回的是一个「引用」</span>
    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">DerefMut</span><span class="p">:</span> <span class="n">Deref</span> <span class="p">{</span>
    <span class="c1">// 注意：这里返回的是一个「引用」</span>
    <span class="k">fn</span> <span class="nf">deref_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="p">::</span><span class="n">Target</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>其中，通过 self 可以拿到（own 这个值，或者有这个值的「引用」）类型为 Target 的值，而且 deref 会返回这个值的「引用」，同时 2 者生命周期保持一致<li>而且，DerefMut 需要实现 Deref</ul><p>给一个 Box 的对 Deref 实现的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="n">Deref</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">MyBox</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="c1">// 注意，这里返回的是 Target 的引用</span>
    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">MyBox</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>再看一下 <strong>deref coercions</strong>。</p><p><strong>deref coercions</strong>：one type is being “coerced” into behaving as another。也就是自动把一个类型的「引用」转换为另外一个类型的「引用」。</p><p>简单点说，如果实现了 Defer（入参是 &amp;self，返回是 &amp;Self::Target），就有了自动 &amp;U 转换为 &amp;T 的效果。如果 Rust 发现当前使用 &amp;U 会编译失败，需要 &amp;T 才能编译通过；同时又发现该类型 U 提供的 Deref 实现了 &amp;U 到 &amp;T，Rust 就会自动做这种转换。例如：</p><ul><li><code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> 实现了 <code class="language-plaintext highlighter-rouge">Deref&lt;Target=T&gt;</code>。对 <code class="language-plaintext highlighter-rouge">Rc&lt;String&gt;</code>，如果要调用 <code class="language-plaintext highlighter-rouge">String::find</code> 方法，<code class="language-plaintext highlighter-rouge">r.find('?')</code> 可以通过编译（等价于 <code class="language-plaintext highlighter-rouge">(*r).find('?')</code>）<ul><li>Rust 自动做了转换：&amp;Rc -&gt; &amp;String</ul><li><code class="language-plaintext highlighter-rouge">String</code> 实现了 <code class="language-plaintext highlighter-rouge">Deref&lt;Target=str&gt;</code>。所以可以 coerce 一个 <code class="language-plaintext highlighter-rouge">&amp;String</code> 的值到 <code class="language-plaintext highlighter-rouge">&amp;str</code><li><code class="language-plaintext highlighter-rouge">Vec&lt;T&gt;</code> 实现了 Deref&lt;Target=[T]&gt;。所以可以把 bytes vector 传给一个入参是 slice &amp;[u8] 的函数</ul><p>最后还是给一个 MyBox 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="n">Deref</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">MyBox</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Deref</span> <span class="k">for</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Target</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>

    <span class="c1">// 注意，这里返回的是 Target 的引用</span>
    <span class="k">fn</span> <span class="nf">deref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">::</span><span class="n">Target</span> <span class="p">{</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="na">.0</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">y</span><span class="p">:</span> <span class="n">MyBox</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">MyBox</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="o">*</span><span class="n">y</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">m</span> <span class="o">=</span> <span class="nn">MyBox</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello it"</span><span class="p">));</span>

    <span class="c1">// &amp;MyBox&lt;String&gt; -&gt; &amp;String -&gt; &amp;str</span>
    <span class="nf">hello</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"OK, {}!"</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="default"><span class="mr-2">Default</span><a href="#default" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>实现了 Default（std::default::Default）这个 trait，可以通过实现这个 trait 来给类型设置默认值。trait 定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nb">Default</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>给个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">impl</span> <span class="nb">Default</span> <span class="k">for</span> <span class="nb">String</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">default</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="asref-and-asmut"><span class="mr-2">AsRef and AsMut</span><a href="#asref-and-asmut" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>这 2 个 traits 定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="nb">AsMut</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_mut</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>当需要借用（borrow）一个 &amp;T 的时候，可以直接传入实现了这 2 个 traits 的类型的值。给个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="c1">// 该函数的本义是需要一个 &amp;Path（借用 Path 的值）类型的入参</span>
<span class="k">fn</span> <span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Path</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="p">{}</span>
</pre></table></code></div></div><p>但事实上，为了方便，该函数的声明可以是下面这个样子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="c1">// 入参是一个 AsRef&lt;Path&gt;，这样所有实现了 AsRef&lt;Path&gt; 的类型的值都可以传入这个函数（例如：String 和 str）</span>
<span class="k">fn</span> <span class="n">open</span><span class="o">&lt;</span><span class="n">P</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="n">P</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="p">{}</span>
</pre></table></code></div></div><p>这种机制提供了引用间的类型转换，有点类似 C++ 中的函数参数的重载（overload）：</p><ul><li>如果类型 U 实现了 <code class="language-plaintext highlighter-rouge">AsRef&lt;T&gt;</code>，则 as_ref 可以实现 &amp;U 到 &amp;T 的转换<li>如果类型 U 实现了 <code class="language-plaintext highlighter-rouge">AsMut&lt;T&gt;</code>，则 as_ref 可以实现从 &amp;U 到 &amp;mut T 的转换</ul><p>给个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">print_ref</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="k">impl</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">v</span><span class="nf">.as_ref</span><span class="p">());</span>
<span class="p">}</span>

<span class="nd">#[allow(dead_code)]</span>
<span class="k">enum</span> <span class="n">Msg</span> <span class="p">{</span>
    <span class="n">Hello</span><span class="p">,</span>
    <span class="n">World</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Msg</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">as_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="nn">Msg</span><span class="p">::</span><span class="n">Hello</span> <span class="k">=&gt;</span> <span class="s">"hello"</span><span class="p">,</span>
            <span class="nn">Msg</span><span class="p">::</span><span class="n">World</span> <span class="k">=&gt;</span> <span class="s">"world"</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// s1 是 &amp;str 类型, str 类型实现了 AsRef&lt;str&gt;，&amp;str 也实现了 AsRef&lt;str&gt;</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
    <span class="c1">// s2 是 String 类型, 实现了 AsRef&lt;str&gt;, &amp;String 也实现了 AsRef&lt;str&gt;</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"word"</span><span class="p">);</span>
    <span class="c1">// msg 是 Msg 类型, 实现了 AsRef&lt;str&gt;, &amp;Msg 也实现了 AsRef&lt;str&gt;</span>
    <span class="k">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="nn">Msg</span><span class="p">::</span><span class="n">Hello</span><span class="p">;</span>

    <span class="c1">// str 类型实现了 AsRef&lt;str&gt;</span>
    <span class="nf">print_ref</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span> <span class="c1">// hello</span>
    <span class="c1">// &amp;str 类型实现了 AsRef&lt;str&gt;</span>
    <span class="nf">print_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span> <span class="c1">// hello</span>

    <span class="c1">// &amp;String 实现了 AsRef&lt;str&gt;</span>
    <span class="nf">print_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span> <span class="c1">// world</span>
    <span class="c1">// String 实现了 AsRef&lt;str&gt;</span>
    <span class="nf">print_ref</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="c1">// world</span>

    <span class="c1">// &amp;Msg 实现了 AsRef&lt;str&gt;</span>
    <span class="nf">print_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">msg</span><span class="p">);</span> <span class="c1">// hello</span>
    <span class="c1">// Msg 实现了 AsRef&lt;str&gt;</span>
    <span class="nf">print_ref</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span> <span class="c1">// hello</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="borrow-and-borrowmut"><span class="mr-2">Borrow and BorrowMut</span><a href="#borrow-and-borrowmut" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Borrow 的定义：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Borrowed</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">borrow</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="n">Borrowed</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>从其定义上看，Borrow 和 AsRef 非常类似。用一个例子说明 2 者的区别：</p><ul><li>String 实现了<code class="language-plaintext highlighter-rouge">AsRef&lt;str&gt;</code>，<code class="language-plaintext highlighter-rouge">AsRef&lt;[u8]&gt;</code>，和 <code class="language-plaintext highlighter-rouge">AsRef&lt;Path&gt;</code>，但这 3 个类型（str，u8，Path） 的 hash 值各不相同，不能保持一致。其中只有 &amp;str slice 的 hash 值能和原类型 String 的 hash 值保持一致，所以 String 类型只会实现 <code class="language-plaintext highlighter-rouge">Borrow&lt;str&gt;</code>。</ul><p>Borrow trait 主要用于 hash 表，或其他的集合类型里的 key 值的 hash 值计算。给个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">K</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面这个例子里面的实现是需要用一个 k 来获取 Map 的 v，但这里的 k 是 String 类型，传入了一个 &amp;K。调用它的一个例子： hashtable.get( &amp; “twenty-two”.to_string())</p><p>该调用的开销如下：</p><ul><li>分配空间（”twenty-two”）<li>拷贝字符串（”twenty-two”.to_string()）<li>执行 drop，销毁 String（调用结束）</ul><p>为了更高效，可以改进为：入参是类型 Q，只要类型 Q 满足 Eq + Hash。同时，Map 中的 K 需要满足约束：实现了 <code class="language-plaintext highlighter-rouge">Borrow&lt;Q&gt;</code>：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">impl</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K</span><span class="p">,</span> <span class="n">V</span><span class="o">&gt;</span> <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="n">get</span><span class="o">&lt;</span><span class="n">Q</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Q</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;&amp;</span><span class="n">V</span><span class="o">&gt;</span>
        <span class="k">where</span> <span class="n">K</span><span class="p">:</span> <span class="n">Borrow</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;</span><span class="p">,</span>
              <span class="n">Q</span><span class="p">:</span> <span class="nb">Eq</span> <span class="o">+</span> <span class="n">Hash</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>简单点说，就是利用 Borrow 这个 trait 来对类型 K 进行约束。</p><h3 id="from-and-into"><span class="mr-2">From and Into</span><a href="#from-and-into" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>类型转换：把一个类型的值转换为另外一个类型的值<ul><li>和 AsRef 不同，AsRef 进行的引用间的转换；而 From 和 Into 是值之间的转换</ul></ul><p>定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="nb">Into</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">into</span><span class="p">(</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">:</span> <span class="nb">Sized</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">other</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>和 AsRef 差不多，Into 也有点像 overload（重载）<li>From 常用来进行值的初始化</ul><h2 id="input-output"><span class="mr-2">input output</span><a href="#input-output" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust 的 IO 标准库重点就是 3 个 traits：</p><ul><li><strong>Read</strong>：统称 Reader，具体的实现包括：Stdin，File，TcpStream<li><strong>BufRead</strong>：也是 Reader 的一种：就是 buffered Reader，继承了 Read trait；其内部有 buffer，这样读的效率会更高效。具体的实现包括：BufferReader，Cursor，StdinLock<ul><li>如果需要在一个文件上重复读很多次，每次又只读少量数据，会比较低效；先读大块数据到 buffer 里面会更高效<li>比如 File 类型只实现了 Read，如果需要更高效的读文件，可以考虑使用实现了 BufRead 的 BufReader</ul><li><strong>Write</strong>：统称 Writer，具体的实现包括：Stdout，Stderr，File。。。</ul><h3 id="read"><span class="mr-2">Read</span><a href="#read" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>这里只重点介绍一些重点方法：</p><ul><li>reader.read(&amp;mut buffer)：把 byte 数据读到指定的 buffer 中（buffer 空间事先已经分配好了），然后返回实际读到的数据的长度。如果出错的话，就返回 io::Error<li>reader.read_to_end(&amp;mut byte_vec)：把整个数据内容读到 byte_vec （<code class="language-plaintext highlighter-rouge">Vec&lt;u8&gt;</code>）中</ul><h3 id="bufread"><span class="mr-2">BufRead</span><a href="#bufread" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>BufRead 的重点方法：</p><ul><li>reader.read_line(&amp;mut line)：按 line 把数据读入到一个 String 类型中（结果包括行分割符：\n，\r\n）。返回本次读到的 byte 数<li>reader.lines()：返回一个 iterator，然后通过迭代拿到一个 <code class="language-plaintext highlighter-rouge">io::Result&lt;String&gt;</code>；同时 \n 不会被放到读到的 String 中</ul><p>一个例子，利用 BufReader（实现了 BufRead）来读取文件：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">BufReader</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">io</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// File 没有 buffer</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="s">"foo.txt"</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
    <span class="c1">// 使用带 buffer 的 BufReader</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="nn">BufReader</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

    <span class="c1">// BufReader 实现了 BufRead，可以利用 lines() 方法来读取文件，更加高效</span>
    <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">f</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">line</span><span class="nf">.unwrap</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nf">Ok</span><span class="p">(())</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="write"><span class="mr-2">Write</span><a href="#write" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li>利用 write!() 和 writeln!() 这 2 个宏来使用 Write<li>Write 的重点方法：<ul><li>write(&amp;buf)：把 byte 数据写出。成功的话，返回写入的大小；失败的话，返回 Error<li>flush()：把数据 flush 到写入目标</ul><li>Write 本身可以创建对应的 BufWriter。例如：BufWriter::new(writer)；并且 BufWriter 也继承了 Write trait<ul><li>BufWriter 被 drop 的时候，会自动把被 buffer 的数据写出。但如果出现 Error，不保证能成功，所以有可能需要显示调用 flush</ul></ul><h2 id="threads"><span class="mr-2">threads</span><a href="#threads" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>首先明确一点：线程适合同时消耗多个 CPU 并行计算的场景；而不适合同时等待多个 IO 请求（磁盘或网络）的场景。</p><p>给一个最简单的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="c1">// do stuff in a child thread</span>
    <span class="p">});</span>

    <span class="c1">// do stuff in the main thread</span>

    <span class="c1">// block until child thread has exited</span>
    <span class="n">handle</span><span class="py">.join</span><span class="nf">.upwrap</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>一个复杂的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="k">log</span><span class="p">::{</span><span class="n">error</span><span class="p">,</span> <span class="n">info</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">thread</span><span class="p">,</span> <span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">};</span>

<span class="k">fn</span> <span class="nf">sleep</span><span class="p">(</span><span class="n">seconds</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="p">{</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs_f32</span><span class="p">(</span><span class="n">seconds</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">dad</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">info</span><span class="p">,</span> <span class="n">sleep</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">cook_spaghetti</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Cooking the spaghetti..."</span><span class="p">);</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mf">4.0</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Spaghetti is ready!"</span><span class="p">);</span>
        <span class="k">true</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">mom</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::{</span><span class="n">info</span><span class="p">,</span> <span class="n">sleep</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">cook_sauce_and_set_table</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Cooking the sauce..."</span><span class="p">);</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Sauce is ready! Setting the table..."</span><span class="p">);</span>
        <span class="nf">sleep</span><span class="p">(</span><span class="mf">2.0</span><span class="p">);</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Table is set!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nn">env_logger</span><span class="p">::</span><span class="nf">init</span><span class="p">();</span>
    <span class="c1">// dad 在工作子线程进行工作</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="nn">dad</span><span class="p">::</span><span class="nf">cook_spaghetti</span><span class="p">());</span>

    <span class="c1">// mom 在主线程进行工作</span>
    <span class="nn">mom</span><span class="p">::</span><span class="nf">cook_sauce_and_set_table</span><span class="p">();</span>

    <span class="c1">// 主线程和工作子线程的工作都完成后，整体完成</span>
    <span class="k">if</span> <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="k">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">info!</span><span class="p">(</span><span class="s">"Spaghetti time! Yum!"</span><span class="p">)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nd">error!</span><span class="p">(</span><span class="s">"Dad messed up the spaghetti. Order pizza instead?"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="channels"><span class="mr-2">Channels</span><a href="#channels" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Rust 线程间的通讯需要使用 channel。注意：</p><ul><li>不推荐使用 std::sync::mpsc<li>推荐使用 <strong>crossbeam::channel</strong>（性能好，功能多；唯一的缺点可能只有不是标准库）</ul><blockquote><p>A channel is a one-way conduit for sending values from one thread to another（Rust 保证 channel 线程安全）</p></blockquote><p>channel 又分为有界队列和无界队列 2 种：</p><ul><li>channel::bounded(8)：队列长度为 8；如果队列长度大于 8，生产者（sender）会被阻塞；直到消费者（receiver）消费后才能解开<li>channel::unbounded()：无界队列；不会阻塞生成者，但发生突发负载时，系统可能爆<li>同一个 channel 可以有多个生产者和多个消费者</ul><p>一个完整的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">crossbeam</span><span class="p">::</span><span class="nn">channel</span><span class="p">::{</span><span class="k">self</span><span class="p">,</span> <span class="n">Receiver</span><span class="p">,</span> <span class="n">Sender</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="n">thread</span><span class="p">,</span> <span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">};</span>

<span class="nd">#[derive(Debug)]</span>
<span class="k">enum</span> <span class="n">Lunch</span> <span class="p">{</span>
    <span class="n">Soup</span><span class="p">,</span>
    <span class="n">Salad</span><span class="p">,</span>
    <span class="n">Sandwich</span><span class="p">,</span>
    <span class="n">HotDog</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 不断接受 orders 队列过来的任务，然后对不同类型的食物做一个对应的处理，最后处理好的食物送给 lunches 队列</span>
<span class="k">fn</span> <span class="nf">cafeteria_worker</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">orders</span><span class="p">:</span> <span class="n">Receiver</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">lunches</span><span class="p">:</span> <span class="n">Sender</span><span class="o">&lt;</span><span class="n">Lunch</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 一旦 orders 队列所有的 senders 都被关闭，且队列中的数据被消费完，循环结束</span>
    <span class="k">for</span> <span class="n">order</span> <span class="k">in</span> <span class="n">orders</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} receives an order for {}"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">lunch</span> <span class="o">=</span> <span class="k">match</span> <span class="o">&amp;</span><span class="n">order</span> <span class="p">{</span>
            <span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"soup"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Lunch</span><span class="p">::</span><span class="n">Soup</span><span class="p">,</span>
            <span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"salad"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Lunch</span><span class="p">::</span><span class="n">Salad</span><span class="p">,</span>
            <span class="n">x</span> <span class="k">if</span> <span class="n">x</span><span class="nf">.contains</span><span class="p">(</span><span class="s">"sandwich"</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="nn">Lunch</span><span class="p">::</span><span class="n">Sandwich</span><span class="p">,</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nn">Lunch</span><span class="p">::</span><span class="n">HotDog</span><span class="p">,</span>
        <span class="p">};</span>
        <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">order</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs_f32</span><span class="p">(</span><span class="mf">0.1</span><span class="p">))</span>
        <span class="p">}</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{} sends a {:?}"</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">lunch</span><span class="p">);</span>
        <span class="c1">// lunches 队列被关闭的话，整个循环结束</span>
        <span class="k">if</span> <span class="n">lunches</span><span class="nf">.send</span><span class="p">(</span><span class="n">lunch</span><span class="p">)</span><span class="nf">.is_err</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 新建 2 个 channels：orders 和 lunches</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">orders_tx</span><span class="p">,</span> <span class="n">orders_rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">channel</span><span class="p">::</span><span class="nf">unbounded</span><span class="p">();</span>
    <span class="c1">// orders 队列有 2 个 receivers</span>
    <span class="k">let</span> <span class="n">orders_rx2</span> <span class="o">=</span> <span class="n">orders_rx</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">lunches_tx</span><span class="p">,</span> <span class="n">lunches_rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">channel</span><span class="p">::</span><span class="nf">unbounded</span><span class="p">();</span>
    <span class="c1">// lunches 队列有 2 个 senders</span>
    <span class="k">let</span> <span class="n">lunches_tx2</span> <span class="o">=</span> <span class="n">lunches_tx</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="c1">// 创建 2 个工作子线程负责处理任务：</span>
    <span class="c1">// orders_rx 从 orders 里面接受任务，处理完成后再使用 lunches_tx 发送给  lunches</span>
    <span class="c1">// orders_rx2 从 orders 里面接受任务，处理完成后再使用 lunches_tx2 发送给  lunches</span>
    <span class="k">let</span> <span class="n">alice_handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="nf">cafeteria_worker</span><span class="p">(</span><span class="s">"alice"</span><span class="p">,</span> <span class="n">orders_rx2</span><span class="p">,</span> <span class="n">lunches_tx2</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">zack_handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="nf">cafeteria_worker</span><span class="p">(</span><span class="s">"zack"</span><span class="p">,</span> <span class="n">orders_rx</span><span class="p">,</span> <span class="n">lunches_tx</span><span class="p">));</span>

    <span class="k">for</span> <span class="n">order</span> <span class="k">in</span> <span class="nd">vec!</span><span class="p">[</span>
        <span class="s">"polish dog"</span><span class="p">,</span>
        <span class="s">"caesar salad"</span><span class="p">,</span>
        <span class="s">"onion soup"</span><span class="p">,</span>
        <span class="s">"reuben sandwich"</span><span class="p">,</span>
    <span class="p">]</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"ORDER: {}"</span><span class="p">,</span> <span class="n">order</span><span class="p">);</span>
        <span class="c1">// orders 只有 1 个 sender（主线程）</span>
        <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">orders_tx</span><span class="nf">.send</span><span class="p">(</span><span class="n">order</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// 不会清空已经发送到队列的数据，但会关闭这个 sender。之后，一旦队列所有的 senders 都已经关闭，消费者的循环会结束</span>
    <span class="nf">drop</span><span class="p">(</span><span class="n">orders_tx</span><span class="p">);</span>

    <span class="c1">// lunches 只有 1 个 receiver（主线程）</span>
    <span class="k">for</span> <span class="n">lunch</span> <span class="k">in</span> <span class="n">lunches_rx</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Order Up! -&gt; {:?}"</span><span class="p">,</span> <span class="n">lunch</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 最后，简单的退出子线程</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">alice_handle</span><span class="nf">.join</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">_</span> <span class="o">=</span> <span class="n">zack_handle</span><span class="nf">.join</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="arc"><span class="mr-2">Arc</span><a href="#arc" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><ul><li><code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code>：原子引用计数<ul><li><code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> 是一种「智能指针」，和 <code class="language-plaintext highlighter-rouge">Rc&lt;T&gt;</code> 功能上类似，不同之处只是因为是<strong>原子计数</strong>，所以能保证<strong>线程安全</strong><li>对一个分配在堆上的 T 值，可以有多个 <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> 指针指向这个 T 值。只有当指向这个 T 值的所有指针都被销毁后，这个 T 值才也被销毁（引用计数为 0）</ul></ul><p>一个简单的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// foo 指向一个值</span>
    <span class="k">let</span> <span class="n">foo</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="c1">// bar 也指向这个值（也就是引用计数加一）</span>
    <span class="k">let</span> <span class="n">bar</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">foo</span><span class="p">);</span>

    <span class="c1">// 启动一个子线程，这个子线程内部，会在 20 毫秒后，发生一次 move，使用这个值，然后引用计数减一</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">20</span><span class="p">));</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="o">*</span><span class="n">bar</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="c1">// 主线程会立即进行 move，使用这个值，然后引用计数减一</span>
    <span class="c1">// 但此时引用计数还没有被减到 0，所以这个值在主线程执行之后不会被销毁</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">foo</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>默认场景 <code class="language-plaintext highlighter-rouge">Arc&lt;T&gt;</code> 不能是可变的（mut）。如果需要可变，可以配合 Mutex 使用</ul><p>一个简单的配合 Mutex 使用的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="n">Mutex</span><span class="p">,</span> <span class="nb">Arc</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">handles</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[];</span>

    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="c1">// 引用计数加一</span>
        <span class="k">let</span> <span class="n">counter</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">clone</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">);</span>
        <span class="c1">// 启动一个新子线程，子线程内部操作获取 Mutex 的 lock，然后对其中的数据 num 进行先读后写</span>
        <span class="c1">// 这里不能直接使用 Mutex，而是要套一层 Arc；</span>
        <span class="c1">// 因为直接使用 Mutex 的话，一旦前一次循环把 Mutex 的值 move 走，后面的循环就不能再使用这个 Mutex</span>
        <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">num</span> <span class="o">=</span> <span class="n">counter</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>

            <span class="o">*</span><span class="n">num</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="c1">// 当前线程结束后，会释放 lock，其它子线程能再获取这个 lock</span>
        <span class="p">});</span>
        <span class="n">handles</span><span class="nf">.push</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 等待所有子线程完成</span>
    <span class="k">for</span> <span class="n">handle</span> <span class="k">in</span> <span class="n">handles</span> <span class="p">{</span>
        <span class="n">handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// 最后输出：Result: 10</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Result: {}"</span><span class="p">,</span> <span class="o">*</span><span class="n">counter</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="async"><span class="mr-2">async</span><a href="#async" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>先明确几个概念：</p><ul><li>Future：对<strong>计算</strong>本身的抽象（重点关注 what：计算什么）<ul><li>Future 只是描述计算本身：”开始做 X，等到 X 做成功后，再做 Y“（而不是「过程式」的运行一段代码：”先执行 X，执行 X 成功后，执行 Y“）<ul><li>简单点说，就是用来描述一个状态机</ul><li>Future 本身不执行代码，Future 只有配合 Executor 才能真正的把代码运行起来，推进状态机</ul><li>Executor：用来真正的把 Future 执行起来（重点关注：when &amp; how：计算什么时候执行，怎么执行）<ul><li>当前 Rust 语言本身只定义 Future 等异步组件相关的 traits，Executor 的实现由<strong>异步运行时</strong>（async_std，tokio 等开源库）负责</ul></ul><h3 id="future"><span class="mr-2">Future</span><a href="#future" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Rust 中，Future 是一个 trait，其定义大致（简化版）如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">trait</span> <span class="n">Future</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>
    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其中 Poll 的定义大致如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Future 完成时返回 Ready</span>
    <span class="nf">Ready</span><span class="p">(</span><span class="n">T</span><span class="p">),</span>
    <span class="c1">// Future 还没有完成的话，返回 Pending</span>
    <span class="n">Pending</span>
<span class="p">}</span>
</pre></table></code></div></div><p>When a future eventually returns Poll::Ready(T), we say that the future resolves into a T</p><blockquote><p>翻译：当一个 Future 实例完成后，会返回 Poll::Ready(T)，这时我们可以说这个 Future 实例被 resolve 成一个类型 T 的返回值</p></blockquote><p>为了更容易理解，Future 还可以分为 2 类：</p><ul><li>leaf Futures（底层 Future）：直接封装某种 IO 操作的异步调用（由 async_std，tokio 等开源库实现）。tokio 库的例子：</ul><div class="language-text highlighter-rouge"><div class="code-header"> <span data-label-text="Text"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>// 异步的创建 socket 连接，并返回一个 **leaf-future**：stream
let mut stream = tokio::net::TcpStream::connect("127.0.0.1:3000");
</pre></table></code></div></div><ul><li>non-leaf Futures（非底层 Future）：多个 Futures 组合起来描述一个异步任务，事实上是一个状态机（开发者进行开发）。例如：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">// 创建了一个异步任务（事实上是一个有 4 个状态的状态机）</span>
<span class="c1">// 其中用到了 async/.await（这里只是先举例，接下来会对它们详细介绍）</span>
<span class="c1">// 最后成功的构建出一个 non-leaf Future</span>
    <span class="k">let</span> <span class="n">non_leaf</span> <span class="o">=</span> <span class="k">async</span> <span class="p">{</span>
<span class="c1">// 状态 1：创建 socket 连接。这里使用了一个 leaf Future，并进行等待</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">stream</span> <span class="o">=</span> <span class="nn">TcpStream</span><span class="p">::</span><span class="nf">connect</span><span class="p">(</span><span class="s">"127.0.0.1:3000"</span><span class="p">)</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="c1">// 状态 2: socket 连接成功</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"connected!"</span><span class="p">);</span>
<span class="c1">// 状态 3：异步写文件，并等待中</span>
        <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stream</span><span class="nf">.write</span><span class="p">(</span><span class="s">b"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span><span class="k">.await</span><span class="p">;</span>
<span class="c1">// 状态 4: 写完成</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"message sent!"</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="asyncawait"><span class="mr-2">async/.await</span><a href="#asyncawait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>怎么创建一个 non-leaf 类型的 Future 来描述异步任务（状态机）？Rust 提供了 async/.await 机制供开发者使用，可以利用它们构建一个描述异步任务的 Future。</p><p>先分别给一下同步读文件和异步读文件的例子，对比一下看看。</p><p>同步：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">};</span>

    <span class="k">fn</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">contents</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">file</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">contents</span><span class="p">)</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>异步（使用 async_std <strong>异步运行时</strong>库）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre>
<span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">extern</span> <span class="k">crate</span> <span class="n">async_std</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">async_std</span><span class="p">::{</span><span class="nn">fs</span><span class="p">::</span><span class="n">File</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="nn">io</span><span class="p">::</span><span class="nn">prelude</span><span class="p">::</span><span class="o">*</span><span class="p">};</span>

    <span class="c1">// 实际上时返回一个 Future：Future&lt;Output = io::Result&lt;String&gt;&gt;</span>
    <span class="k">async</span> <span class="k">fn</span> <span class="nf">read_file</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nn">io</span><span class="p">::</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">String</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="c1">// 可以把整个 read_file 异步函数理解成一个状态机。</span>

        <span class="c1">// File::open(path) 本身返回一个 Future</span>
        <span class="c1">// .await 是关键，使用了 .await 后，当真正执行到这里时，状态机进入等待状态</span>
        <span class="c1">// 直到 open 成功后，能拿到 Ready(T) 中的 T：file。当前状态结束，状态机继续推进到下个状态</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">file</span> <span class="o">=</span> <span class="nn">File</span><span class="p">::</span><span class="nf">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">contents</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">file</span><span class="nf">.read_to_string</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">contents</span><span class="p">)</span><span class="k">.await</span><span class="o">?</span><span class="p">;</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">contents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p><strong>NOTE</strong>：如果 executor 有多个线程，那么 Future 恢复执行后有可能会到另外一个线程里去执行，需要注意线程安全（互斥和死锁）</p></blockquote><hr /><ul><li>通过 async/.await 机制创建异步任务（也就是 non-leaf 类型的 Futures）的惯用法：<ul><li>开发者使用 async fn 来定义一个异步函数，异步函数返回一个 non-leaf 类型的 Future<ul><li>然后需要由<strong>异步运行时</strong>库来真正执行这个 Future</ul><li>在异步函数内部，需要使用「异步」版本的 IO 函数（由异步运行时提供）<ul><li>「异步」版本的 IO 函数不会直接返回 IO 操作结果，而是会返回一个异步 IO Future（也就是 leaf Futures）<li>再配合 .await 使用异步 IO Future，执行时等待异步 IO 成功后，会返回异步 IO 的结果</ul></ul></ul><hr /><ul><li>生命周期<ul><li>async fn 的入参如果是 non-‘static 参数（非 static 生命周期的参数），那么这个 async fn 返回的 Future 的生命周期需要被限制在函数入参的生命周期之内<ul><li>换句话说，当在这个 Future 上做 .await 的时候，当初调用这个 async fn 时的入参的生命周期必须仍然有效</ul></ul></ul><hr /><ul><li>async move 代码块：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// `async move` block:</span>
<span class="c1">// 如果某个 `async move` block 使用了外部的 my_string 这个变量后, 其他的 `async move` block 就不能使用这个变量了</span>

<span class="k">fn</span> <span class="nf">move_block</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Output</span><span class="o">=</span><span class="p">()</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">my_string</span> <span class="o">=</span> <span class="s">"foo"</span><span class="nf">.to_string</span><span class="p">();</span>
    <span class="k">async</span> <span class="k">move</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">my_string</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="pin"><span class="mr-2">Pin</span><a href="#pin" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Pin 机制最重要的用途就是用来保证 Rust 异步机制的安全。</p><p>本节深入介绍 <strong>Pin</strong> 的细节。</p><h4 id="可移动"><span class="mr-2">可移动</span><a href="#可移动" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>进入本节之前，建议参考 <a href="#move">move</a> 对 move 的概念进行回顾。</p><p>用一个例子再详解一下 move 的细节：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// s1 (变量) 是 String `hello` (值) 的 owner</span>
    <span class="c1">// 底层的实现大概是：`hello` 被存放在分配在 heap 上的空间</span>
    <span class="c1">// s1 是个肥指针：记录了「字符串长度」，「字符串存放空间地址」等信息</span>
    <span class="k">let</span> <span class="n">s1</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>

    <span class="c1">// 进行 move：s1 记录的信息被 copy 给了 s2（「字符串长度」，「字符串存放空间地址」）</span>
    <span class="c1">// 但字符串内容（`hello`）本身地址不会变动</span>
    <span class="c1">// 移动以后可以使用 s2 完全没有问题</span>
    <span class="c1">// 这是因为 String `hello` 本身的地址没有变化，可以通过 s2 被安全的继续使用</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面例子中的 s1 move 到 s2 具体动作如下图（从 TRPL 书摘录）所示：</p><p><img data-src="https://doc.rust-lang.org/stable/book/img/trpl04-02.svg" alt="move" width="300" data-proofer-ignore></p><p>就上面的例子来说，String 类型是一个「可移动」（movable）类型。</p><blockquote><p><strong>可移动</strong>（movable）：所谓一个类型「可移动」，是指一旦拿到这个类型的「值」的 ownership 或 &amp;mut（独占指针），并进行 move 操作，而不会引起问题（不会发生<strong>未定义行为</strong>）</p></blockquote><p>正常来说，就像上面的 String 类型，Rust 中的所有类型都应该是「可移动」的。</p><p>但有例外的场景，某些类型被移动后，会有问题。比如对 <strong>Self-Referential Structs</strong>（自引用 structs）类型进行 move 就可能引起问题（发生<strong>未定义行为</strong>）。</p><p>举个 <strong>Self-Referential Structs</strong> 的例子（一个字段指向另外一个字段）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">Test</span> <span class="p">{</span>
    <span class="n">a</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">b</span><span class="p">:</span> <span class="o">*</span><span class="k">const</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><p>自引用 structs 的 move 问题的细节请参考：<a href="https://rust-lang.github.io/async-book/04_pinning/01_chapter.html#pinning-in-detail">Pinning in Detail</a>，看了它里面的图就一目了然了：</p><p><img data-src="https://rust-lang.github.io/async-book/assets/swap_problem.jpg" alt="async" width="500" data-proofer-ignore></p><p>总之 <strong>Self-Referential Structs</strong> 可能会引起 move 后的指针无效问题。该问题可能的解决方法有：</p><ul><li>每次 move 时，修改指针指向的地址；但这个方法会影响运行时的性能，代价较高<li>指针不储存绝对地址，只储存偏移量；这样需要编译器针对 <strong>Self-Referential Structs</strong> 做专门的处理，编译器的实现会比较复杂<li>Rust 采用 <strong>Pin</strong> 机制来解决问题：开发者负责把不能被 move 的类型标记出来；利用类型系统对这些被标记了的类型进行限制：使得没有办法对这些类型做 move 动作<ul><li>运行时付出的代价为 0，不影响性能<li>代价就是开发者需要学习 Pin 的用法</ul></ul><h4 id="pin-的定义"><span class="mr-2">Pin 的定义</span><a href="#pin-的定义" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><blockquote><p><strong>核心理念</strong>：</p><p>要限制一个类型 T 不能被 move，也就是要对这个类型 T 的访问进行限制：只要不能拿到到这个类型 T 的 ownership 或者 &amp;mut T（独占指针），也就不能对这个类型 T 做 move 操作。</p><p>在 Pin 机制中，只要利用 Pin 把这个类型 T 包起来（或者说屏蔽起来）就能实现这个限制效果。</p></blockquote><p>Pin 的定义：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 一个包了指针的 struct</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pointer</span><span class="p">:</span> <span class="n">P</span><span class="p">,</span>
<span class="p">}</span>
</pre></table></code></div></div><p>其中：</p><ul><li>Pin <strong>自己是一个指针</strong>，Pin 本身实现了 Deref 和 DerefMut，<li>P <strong>必须是一个指针</strong>，也就是实现了 Deref 或 DerefMut 的类型。例如：<code class="language-plaintext highlighter-rouge">Box&lt;T&gt;</code></ul><p>怎么利用 Pin 把需要限制的类型 T 包起来（屏蔽起来）？</p><ul><li>因为 P 只能包一个指针，所以先要构建一个指向 T 的指针 P。可以构建 2 种指针：<ul><li><strong>&amp;mut T</strong>：「<strong>可变引用</strong>」实际上就是 T 的「独占指针」<li><strong>Box&lt;T&gt;</strong>：使用智能指针 <strong>Box</strong></ul><li>然后再用 Pin 把构建好的指针类型 P 包起来。既然有 2 种指针，那么也有 2 种 Pin：<ul><li><strong>Pin&lt;&amp;mut T&gt;</strong>：但这种坑多，使用起来需要很小心，<strong>先不推荐使用这种方法</strong><li><strong>Pin&lt;Box&lt;T»</strong>：可以使用标准库 Box::pin 函数来构建。得到一个在 heap 上的 T 的值，然后这个值被 Pin 屏蔽住，<strong>推荐使用这种方法</strong></ul></ul><h4 id="unpin-and-unpin"><span class="mr-2">Unpin and !Unpin</span><a href="#unpin-and-unpin" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>上一节已经说明了通过 Pin 机制，可以把「不可移动」的类型 T 封装到 Pin 中，这样就没有办法获取到 T 的 ownership 或者 &amp;mut T（独占指针），进而保证不能对 T 进行 move。</p><p>但实际上 Pin 是和 Unpin trait 组合在一起使用的，所以还需要详细介绍 Unpin（以及 !Unpin）的概念。</p><blockquote><p>Unpin trait 是一种 <a href="https://doc.rust-lang.org/reference/special-types-and-traits.html#auto-traits"><strong>auto trait</strong></a>。简单点说，Rust 中的各种类型，要么实现了 Unpin，要么实现了 !Unpin（事实上，Rust 中大多数类型都已经默认实现了 Unpin trait）。</p></blockquote><p>配合 Unpin 和 !Unpin，Pin 的使用<strong>原则</strong>如下：</p><p>原则一：</p><blockquote><p>Unpin Types can be safely moved after being pinned。</p><p>如果类型 T 是「可移动」类型，那么需要给该类型 T 实现 Unpin trait。</p><p>一旦类型 T 实现了 Unpin trait，那么即使用 Pin 包住这个类型 T（例如 Pin&lt;&amp;mut T&gt;），也不会对 T 有屏蔽效果。</p><p>还是可以从 Pin 中拿到 T 的 ownership 或者 &amp;mut T（独占指针），并进行 move。</p></blockquote><p>原则二：</p><blockquote><p><strong>Guarantee that an object implementing !Unpin won’t ever be moved</strong>。</p><p>只有当 Pin 包住的类型 T（例如 Pin&lt;Box&lt;T» 中的 T）实现了 !Unpin trait，才无法获取到 T 的 ownership 或者 &amp;mut T（独占指针），从而达到了对 T 的屏蔽效果，没办法对类型 T 进行 move。</p></blockquote><p>原则三：</p><blockquote><p>一个 struct 类型 T 只要有一个 field 是 !Unpin 的，这个 struct 类型 T 就是 !Unpin 的。</p></blockquote><p>而 Rust 中绝大多数正常类型，都是「可移动」的，默认都已经实现了 Unpin。</p><p>比如 String 类型，也已经默认实现了 Unpin。按照上面的「原则一」，即使被 Pin 包住，也不会并屏蔽，可以使用多种方法从 Pin 中拿到 String 进行操作:</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">string</span> <span class="o">=</span> <span class="s">"Pinned?"</span><span class="nf">.to_string</span><span class="p">();</span>

    <span class="c1">// 构建 Pin&lt;&amp;mut T&gt;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pinned</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="nb">String</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Pin</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">string</span><span class="p">);</span>
    <span class="c1">// String 实现了 Unpin，所以不会被 Pin 屏蔽</span>
    <span class="c1">// 可以直接从 Pin&lt;&amp;mut T&gt; 拿到内部真正的 T String，进行操作</span>
    <span class="n">pinned</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" Not"</span><span class="p">);</span>

    <span class="c1">// 也提供了 Pin::into_inner 方法来返回指针 P（相当于可以把外层包的 Pin 去掉）</span>
    <span class="nn">Pin</span><span class="p">::</span><span class="nf">into_inner</span><span class="p">(</span><span class="n">pinned</span><span class="p">)</span><span class="nf">.push_str</span><span class="p">(</span><span class="s">" so much."</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">new_home</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">new_home</span><span class="p">,</span> <span class="s">"Pinned? Not so much."</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>特别注意：</p><ul><li>Box&lt;T&gt; 也是「可移动」的，也实现了 Unpin<ul><li>Box&lt;T&gt; 是一个 heap 上的指针，所以可以安全的移动<li>但 T 可能「不可移动」，可能实现了 !Unpin</ul><li>Pin&lt;Box&lt;T» 也是「可移动」的，也实现了 Unpin<ul><li>Pin 的 field 是 Unpin 的 Box&lt;T&gt;，所以 Pin 也是 Unpin 的<li>但 T 可能「不可移动」，可能实现了 !Unpin</ul></ul><p>在 Rust 中，真正实现了 !Unpin trait 的只有 2 个类型（这里只先提一下，下一节会详细讲）：</p><ul><li>Future 转换为状态机时，编译器生成 <strong>Self-Referential Structs</strong> 来保存状态机上下文数据，编译器会给这些 <strong>Self-Referential Structs</strong> 实现 !Unpin trait<li>标准库中的 std::marker::PhantomPinned 类型也实现了 !Unpin trait</ul><h4 id="future-and-pin"><span class="mr-2">Future and Pin</span><a href="#future-and-pin" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><ul><li>Rust 里面，使用 Future 来描述一个状态机<li>编译器把 async fn 或 async block 转换为状态机代码时，使用到了 <strong>Self-Referential Structs</strong><li>后续使用该 Future 的人如果不小心对这个 Future 进行了 move，就会出问题<li>所以需要使用 Pin 机制来保证 Future 的安全（不会被 move）</ul><p>先简单举例说明怎么把异步代码（async fn 或 async block）转换为状态机（更多细节请参考：<a href="https://os.phil-opp.com/async-await/#the-async-await-pattern">The Async/Await Pattern</a>）。</p><p>这里举个 async block 的简单例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">async</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">128</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">read_into_buf_fut</span> <span class="o">=</span> <span class="nf">read_into_buf</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">read_into_buf_fut</span><span class="k">.await</span><span class="p">;</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>编译器在对这个 async block 生成状态机：</p><ul><li>构建一个有 3 个状态的状态机：StartState，WaitingOnReadState，EndState<li>对每个状态，需要定义对应的 struct 来保存该状态的上下文信息：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// 整个 async block 被转换为一个 future：</span>
<span class="k">struct</span> <span class="n">AsyncFuture</span> <span class="p">{</span>
    <span class="c1">// future 中包括了 async block 内部使用到的数据：</span>
    <span class="n">x</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">128</span><span class="p">],</span>

    <span class="c1">// future 中也需要包含状态机工作时，每个状态的上下文信息（只有记录了每个状态的上下文信息，状态机才能被不断推进）</span>
    <span class="c1">// 本例子中，我们只重点关心 WaitingOnReadState 状态的上下文</span>
    <span class="n">waiting_on_read_state</span><span class="p">:</span> <span class="n">WaitingOnReadState</span><span class="p">,</span>
<span class="p">}</span>

<span class="c1">// 定义一个 WaitingOnReadState 状态的上下文信息的 struct</span>
<span class="k">struct</span> <span class="n">WaitingOnReadState</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// 指向了 AsyncFuture 的 `x` 字段，所以 AsyncFuture 是一个 Self-Referential Struct</span>
    <span class="n">buf</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
<span class="p">}</span>
</pre></table></code></div></div><p>可以看出，async block 的状态机的底层实现中，会把 Future 实现为 <strong>Self-Referential Structs</strong>（自引用 struct），只能利用 Pin 机制来防止使用 Future 的人对 Future 进行 move。</p><h3 id="异步运行时"><span class="mr-2">异步运行时</span><a href="#异步运行时" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>异步运行时由 Rust 社区提供，它们的核心是一个 Reactor 和一个或多个 Executor：</p><ul><li>Reactor 负责封装底层的事件通知，例如 异步 IO，异步 Sleep 等<li>Executor 负责执行 Future（前面的小节已经介绍过）<li>Executor 和 Reactor 利用 <strong>Waker</strong>（Rust 标准库定义）进行交互：<ul><li>Executor 执行 Future 进行 poll，并把 waker 作为调用时的入参<li>Reactor 执行底层 IO 操作，并接收到 waker<li>当 IO 完成时，Reactor 利用 waker 通知 Executor 继续推进 Future 的执行</ul></ul><p>目前有一些流行的「异步运行时」，本节重点介绍 Tokio（值得注意的是，一旦你的项目选择了某个「异步运行时」，不太可能后续又能切到其他的「异步运行时」）。</p><h4 id="main-函数"><span class="mr-2">main 函数</span><a href="#main-函数" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用 Tokio 时，需要用 #[tokio::main] 宏。会把 async fn main 转换为 fn main，以及做一些异步环境的初始化工作。最简单的例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"hello"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="异步任务"><span class="mr-2">异步任务</span><a href="#异步任务" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用 tokio::spawn 创建「异步任务」。tokio::spawn会返回一个 JoinHandle 对象，然后开发者可以通过 JoinHandle 使用这个「异步任务」。最简单的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// spawn 入参是 async block</span>
    <span class="c1">// async block 就是这个「异步任务」要做的事情（本身是返回一个 Future）</span>
    <span class="c1">// 返回一个 JoinHandle（handle）对应这个「异步任务」</span>
    <span class="k">let</span> <span class="n">handle</span> <span class="o">=</span> <span class="nn">tokio</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">async</span> <span class="p">{</span>
        <span class="mi">10086</span>
    <span class="p">});</span>

    <span class="c1">// JoinHandle 本身也是一个 Future</span>
    <span class="c1">// 下面真正的执行这个「异步任务」（执行由「Executor」负责）</span>
    <span class="k">let</span> <span class="n">out</span> <span class="o">=</span> <span class="n">handle</span><span class="k">.await</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"GOT {}"</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h4 id="mutex"><span class="mr-2">Mutex</span><a href="#mutex" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>「异步任务」间数据同步的安全保证，可使用「互斥」。Mutex 的用法可参考之前的小节（Arc）。</p><h3 id="更多底层细节"><span class="mr-2">更多底层细节</span><a href="#更多底层细节" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Future trait 真实定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">trait</span> <span class="n">Future</span> <span class="p">{</span>
        <span class="k">type</span> <span class="n">Output</span><span class="p">;</span>

        <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="p">)</span>
                <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>详解：</p><ul><li><strong>Output</strong> 是 Future 执行完成后返回的值的类型<li>开始调用 poll() 方法之前，必须先用一个 Pin 类型把 Future 包装起来才能调用 poll() 方法<ul><li><strong>用一个 Pin 类型把 Future 包装起来的目的是防止这个 Future 实例被 move</strong></ul><li>由第 3 方异步运行时库提供的 Executor 负责执行 Future：<ul><li>整个状态机由一个最外层 Future，和其它内部 Futures 一起组成<li>Executor 先做第一次 poll，启动状态机<li>Executor 会继续调用 poll，推进状态机，直到整个任务完成</ul></ul><p>但如果 Executor 通过循环重试的方式来不断 poll 效率太低。高效的方式是通过某种通知机制，当 Future 已经就绪时，才去做 poll。所以又引入了 Waker：</p><ul><li><p>当 Executor 调用 poll 的时候需要提供一个 <strong>Context</strong> 参数，这个 Context 参数就包含了 Waker</p><li><p>未来当 Future 完成时，可以获取到 Waker（waker = cx.waker()），然后调用 waker.wake() 来通知 Executor 执行 poll</p><li><p>具体 waker.wake() 要怎么通知，由 Executor 实现：</p><ul><li>一种可能的实现，就是调用 wake() 把就绪的任务加到<strong>就绪队列</strong>，Executor 消费<strong>就绪队列</strong>中已完成任务，进行 poll<li>实现要保证线程安全</ul></ul><p>先展示一个简单的，不断 wake Executor 做 poll 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">,</span>
    <span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">,</span>
    <span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">},</span>
<span class="p">};</span>

<span class="c1">// 这个例子中，我们使用 tokio 作为运行时来执行 Future</span>
<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">fut</span> <span class="o">=</span> <span class="n">MyFuture</span> <span class="p">{};</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Awaiting fut..."</span><span class="p">);</span>
    <span class="n">fut</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Awaiting fut... done!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 声明一个自己的 Future</span>
<span class="k">struct</span> <span class="n">MyFuture</span> <span class="p">{}</span>

<span class="c1">// 实现 Future trait</span>
<span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">MyFuture</span> <span class="p">{</span>
    <span class="c1">// 该 Future 返回 ()</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"MyFuture::poll()"</span><span class="p">);</span>
        <span class="c1">// 如果没有 wake_by_ref() 的话，poll 就只会被调用一次</span>
        <span class="c1">// 现在加上了 wake_by_ref()，每次 poll 时，会再次通知 Executor 进行下一次 poll，Executor 会再次调用 poll</span>
        <span class="n">cx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.wake_by_ref</span><span class="p">();</span>
        <span class="c1">// 但该例子中，无论 poll 多少次都返回 Pending，不会返回 Ready：无限次调用 poll</span>
        <span class="nn">Poll</span><span class="p">::</span><span class="n">Pending</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>执行以后的无限次 poll 的效果如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nv">$ </span>cargo run <span class="nt">--quiet</span>
Awaiting fut...
MyFuture::poll<span class="o">()</span>
MyFuture::poll<span class="o">()</span>
MyFuture::poll<span class="o">()</span>
MyFuture::poll<span class="o">()</span>
MyFuture::poll<span class="o">()</span>
MyFuture::poll<span class="o">()</span>
MyFuture::poll<span class="o">()</span>
MyFutur^C
</pre></table></code></div></div><p>然后再展示一个例子：启动一秒以后，能返回 Ready 的 Future：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Sleep</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::{</span>
    <span class="nn">future</span><span class="p">::</span><span class="n">Future</span><span class="p">,</span>
    <span class="nn">pin</span><span class="p">::</span><span class="nb">Pin</span><span class="p">,</span>
    <span class="nn">task</span><span class="p">::{</span><span class="n">Context</span><span class="p">,</span> <span class="n">Poll</span><span class="p">},</span>
<span class="p">};</span>

<span class="nd">#[tokio::main]</span>
<span class="k">async</span> <span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">fut</span> <span class="o">=</span> <span class="nn">MyFuture</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Awaiting fut..."</span><span class="p">);</span>
    <span class="n">fut</span><span class="k">.await</span><span class="p">;</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"Awaiting fut... done!"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">MyFuture</span> <span class="p">{</span>
    <span class="c1">// Sleep 是一个 Future，不能直接调用 poll()，</span>
    <span class="c1">// 需要 Pin 和 Box 组合起来才能调用 poll（下面一个小节会详细说）</span>
    <span class="n">sleep</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;</span><span class="nb">Box</span><span class="o">&lt;</span><span class="n">Sleep</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">MyFuture</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="c1">// 使用 tokio 异步版本的 sleep</span>
            <span class="c1">// Box::pin 创建一个 Pin&lt;Box&lt;T&gt;，如果 T 没有实现 Unpin 的话，Pin 成功</span>
            <span class="c1">// 本例子 Pin&lt;Box&lt;Sleep&gt;&gt; 中的 Sleep 类型就是没有实现 Unpin 的类型</span>
            <span class="n">sleep</span><span class="p">:</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">pin</span><span class="p">(</span><span class="nn">tokio</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Future</span> <span class="k">for</span> <span class="n">MyFuture</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">Output</span> <span class="o">=</span> <span class="p">();</span>

    <span class="k">fn</span> <span class="nf">poll</span><span class="p">(</span><span class="k">mut</span> <span class="k">self</span><span class="p">:</span> <span class="nb">Pin</span><span class="o">&lt;&amp;</span><span class="k">mut</span> <span class="k">Self</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">cx</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Context</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Poll</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Output</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"MyFuture::poll()"</span><span class="p">);</span>
        <span class="c1">// 这个一个典型的惯用法：Future 的实现里面对另外一个 Future 进行 poll</span>
        <span class="c1">//</span>
        <span class="c1">// 因为异步版本的 sleep 内部实现了利用 waker 来通知 Executor</span>
        <span class="c1">// 所以可以直接对异步版本的 sleep 进行 poll</span>
        <span class="c1">//</span>
        <span class="c1">// 异步版本的 sleep 的 poll()，需要 Pin 和 Box 组合起来调用 poll()</span>
        <span class="k">self</span><span class="py">.sleep</span><span class="nf">.as_mut</span><span class="p">()</span><span class="nf">.poll</span><span class="p">(</span><span class="n">cx</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>执行效果如下：</p><div class="language-shell highlighter-rouge"><div class="code-header"> <span data-label-text="Shell"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nv">$ </span>cargo run <span class="nt">--quiet</span>
Awaiting fut...
MyFuture::poll<span class="o">()</span>
这里会卡 1 秒
MyFuture::poll<span class="o">()</span>
Awaiting fut... <span class="k">done</span><span class="o">!</span>
</pre></table></code></div></div><ul><li>另外一个之前例子没有覆盖的 Future 内部实现细节：每次 Executor 调用 poll 时，都会传入一个的 waker 参数；poll 的内部需要判断这次的 waker 和之前 poll 被调用时传入的 waker 的值是否匹配。代码大概如下：</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 获取原先的 waker</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">waker</span> <span class="o">=</span> <span class="n">waker</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="c1">// 判断原先的 waker 和本次调用传入的 waker 是否匹配</span>
    <span class="k">if</span> <span class="o">!</span><span class="n">waker</span><span class="nf">.will_wake</span><span class="p">(</span><span class="n">cx</span><span class="nf">.waker</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 如果不匹配，需要 clone 本次传入的值，并记录到 Future 内部</span>
        <span class="o">*</span><span class="n">waker</span> <span class="o">=</span> <span class="n">cx</span><span class="nf">.waker</span><span class="p">()</span><span class="nf">.clone</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="closure"><span class="mr-2">closure</span><a href="#closure" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><ul><li><a href="#closure">closure</a> 就是匿名函数，可以赋值给变量，也可以作为函数的参数来使用。例如，可以把 <a href="#closure">closure</a> 作为函数参数的一些库方法：<ul><li>Iterator<li>thread::spawn</ul><li>一般来说，Rust 会自动推断 <a href="#closure">closure</a> 用到的类型。但也可以使用「类型标注」标明其类型</ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="n">Duration</span><span class="p">;</span>

    <span class="c1">// 分别标明了参数和返回值的类型：u32</span>
    <span class="k">let</span> <span class="n">expensive_closure</span> <span class="o">=</span> <span class="p">|</span><span class="n">num</span><span class="p">:</span> <span class="nb">u32</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"calculating slowly..."</span><span class="p">);</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
        <span class="n">num</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><a href="#closure">closure</a> 和函数的不同在于，<a href="#closure">closure</a> 不仅仅可以使用入参，也可以捕获（<strong>capture</strong>）并使用调用者作用域中的值<ul><li>这里可以参考一下后面提到的 <code class="language-plaintext highlighter-rouge">Fn</code>，<code class="language-plaintext highlighter-rouge">FnMut</code>，<code class="language-plaintext highlighter-rouge">FnOnce</code></ul></ul><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// sum 是一个 closure。这个 closure 捕获并使用了作用域中 x 的值（也就是 1）</span>
    <span class="c1">// 注意：这里只是定义了 closure，并不会执行。closure 只有在被调用的时候才会真正执行</span>
    <span class="k">let</span> <span class="n">sum</span> <span class="o">=</span> <span class="p">|</span><span class="n">y</span><span class="p">|</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>

    <span class="c1">// 执行 sum，计算结果是 3</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nf">sum</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li><a href="#closure">closure</a> 会自动 <strong><a href="#borrowing">borrow</a></strong> 捕获的值（默认创建一个指向值的引用，又有 2 种可能：「可变引用」和「不可变引用」）<ul><li>只要 <a href="#closure">closure</a> 自己会在该引用指向的值的之前被 dropped，那么就是符合生命周期规则，没有问题</ul></ul><p>一个简单的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

    <span class="c1">// f 是一个 closure，它捕获 s，并自动进行 borrow</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="c1">// f 这个 closure 在 s 之前被 dropped，所以这段代码是 OK 的</span>
    <span class="nf">f</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>但如果不能保证 <a href="#closure">closure</a> 自己会在该引用指向的值的前面被 dropped，不能通过编译<li>此时可以考虑使用 <strong>move</strong> 关键字，使用 move 关键字后，<a href="#closure">closure</a> 会把捕获的值 <a href="#move">move</a> 到 <a href="#closure">closure</a> 内部，并拿到这个值的 <a href="#ownership">ownership</a><ul><li>然后当这个 <a href="#closure">closure</a> 被 dropped 的时候，这个参数的值也会被 dropped</ul></ul><p>一个简单的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>

    <span class="c1">// f 是一个 closure，它捕获到 s，并进行 move，并拿到 s 的 ownership</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="nf">f</span><span class="p">();</span>

    <span class="c1">// 之后，当 f 这个 closure 被 dropped，s 也会被 dropped</span>
    <span class="c1">// 如果之后还需要使用这个 s，只能在 move 之前 clone 出一份</span>
<span class="p">}</span>
</pre></table></code></div></div><p>一个进行 clone 之后再使用 <a href="#closure">closure</a> 的简单例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"hello"</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.clone</span><span class="p">();</span>

    <span class="c1">// move 的时候，用 s2</span>
    <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">s2</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="nf">f</span><span class="p">();</span>

    <span class="c1">// 之后，当 f 这个 closure 被 dropped，s2 会被 dropped</span>
    <span class="c1">// 而 s 还可以继续被使用</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>用一些更复杂的例子说明更多的细节：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="n">City</span> <span class="p">{</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
    <span class="n">population</span><span class="p">:</span> <span class="nb">i64</span><span class="p">,</span>
    <span class="n">country</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">sort_cities</span><span class="p">(</span><span class="n">cities</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cities</span><span class="nf">.sort_by_key</span><span class="p">(|</span><span class="n">city</span><span class="p">|</span> <span class="o">-</span><span class="n">city</span><span class="py">.population</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>按人口降序排序<li>有点像其他语言（Java）中的匿名函数<li>但 Rust 的 <a href="#closure">closure</a> 和其他语言的匿名函数又有区别</ul><hr /><p>下面的例子，说明了 Closure 相关的生命周期：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="cd">/// Sort by any of several different statistics.</span>
<span class="k">fn</span> <span class="nf">sort_by_statistic</span><span class="p">(</span><span class="n">cities</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">stat</span><span class="p">:</span> <span class="n">Statistic</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Rust 自动 borrow（自动有一个到 stat 的引用）</span>
    <span class="n">cities</span><span class="nf">.sort_by_key</span><span class="p">(|</span><span class="n">city</span><span class="p">|</span> <span class="o">-</span><span class="n">city</span><span class="nf">.get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>线程相关的复杂例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">start_sorting_thread</span><span class="p">(</span><span class="k">mut</span> <span class="n">cities</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">stat</span><span class="p">:</span> <span class="n">Statistic</span><span class="p">)</span>
                        <span class="k">-&gt;</span> <span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;&gt;</span>
<span class="p">{</span>
    <span class="c1">// 定义一个 Closure</span>
    <span class="k">let</span> <span class="n">key_fn</span> <span class="o">=</span> <span class="p">|</span><span class="n">city</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">City</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span> <span class="o">-</span><span class="n">city</span><span class="nf">.get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="p">};</span>

    <span class="c1">// spawn 新的线程</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(||</span> <span class="p">{</span>
        <span class="n">cities</span><span class="nf">.sort_by_key</span><span class="p">(</span><span class="n">key_fn</span><span class="p">);</span>
        <span class="n">cities</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Rust 会提示这段代码编译错误。错误的根源如下：</p><ul><li>这个新的线程的工作完成之前，stat 和 cities 这 2 个变量都必须存活；但上面的代码按 <a href="#borrowing">borrow</a> 的话，没有这个保证</ul><p>解决方法是利用 <strong>move</strong> 关键字告诉 Rust 把 stat 和 cities 这 2 个变量 <a href="#move">move</a> 到 <a href="#closure">closure</a>（而不是像前个例子那样走 <a href="#borrowing">borrow</a> 逻辑）。代码如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">start_sorting_thread</span><span class="p">(</span><span class="k">mut</span> <span class="n">cities</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">stat</span><span class="p">:</span> <span class="n">Statistic</span><span class="p">)</span>
                        <span class="k">-&gt;</span> <span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;&gt;</span>
<span class="p">{</span>
    <span class="c1">// 利用 move 关键字，key_fn closure 获取到 stat 的 ownership</span>
    <span class="k">let</span> <span class="n">key_fn</span> <span class="o">=</span> <span class="k">move</span> <span class="p">|</span><span class="n">city</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">City</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span> <span class="o">-</span><span class="n">city</span><span class="nf">.get_statistic</span><span class="p">(</span><span class="n">stat</span><span class="p">)</span> <span class="p">};</span>

    <span class="c1">// 利用 move 关键字，该 closure 获取到 key_fn 和 cities 的 ownership</span>
    <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="n">cities</span><span class="nf">.sort_by_key</span><span class="p">(</span><span class="n">key_fn</span><span class="p">);</span>
        <span class="n">cities</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>【回顾一下】：<a href="#borrowing">borrow</a> 和 <a href="#move">move</a> 的本质区别在于 <a href="#ownership">ownership</a> 是否改变</ul><hr /><p>再特别说明一下<strong>把函数作为另外一个函数的入参</strong>，和<strong>把 <a href="#closure">closure</a> 作为另外一个函数的入参</strong>的区别。</p><p>先看一个<strong>把函数作为另外一个函数入参</strong>的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cd">/// Given a list of cities and a test function,</span>
<span class="cd">/// 这个 test_fn 就是一个作为入参的函数，其入参是 &amp;City，返回值是 bool：fn(&amp;City) -&gt; bool</span>
<span class="cd">/// return how many cities pass the test.</span>
<span class="k">fn</span> <span class="nf">count_selected_cities</span><span class="p">(</span><span class="n">cities</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">test_fn</span><span class="p">:</span> <span class="k">fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">city</span> <span class="k">in</span> <span class="n">cities</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">test_fn</span><span class="p">(</span><span class="n">city</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">count</span>
<span class="p">}</span>
</pre></table></code></div></div><p>但是不能把一个 <a href="#closure">closure</a> 传给这个例子函数 count_selected_cities。因为 count_selected_cities 的入参是函数而不是 closure。</p><p>如果需要把 closure 作为入参，需要这样定义 count_selected_cities：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cd">/// 这里的入参 test_fn 是一个 F，其实现了一个 trait：Fn(&amp;City) -&gt; bool</span>
<span class="k">fn</span> <span class="nf">count_selected_cities</span><span class="p">(</span><span class="n">cities</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">City</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">test_fn</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span>
    <span class="k">where</span> <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">City</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="n">city</span> <span class="k">in</span> <span class="n">cities</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nf">test_fn</span><span class="p">(</span><span class="n">city</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">count</span>
<span class="p">}</span>
</pre></table></code></div></div><p>也就是说：</p><ul><li><code class="language-plaintext highlighter-rouge">fn(&amp;City) -&gt; bool</code> // fn (只能是把函数作为入参)<li><code class="language-plaintext highlighter-rouge">Fn(&amp;City) -&gt; bool</code> // Fn trait (既可以是函数作为入参，也可以是 closure 作为入参)</ul><p>上面的 Fn 是 Rust 语言支持的 trait。实际上，Rust 一共支持 3 种类型的 closure trait，开发者可以根据具体情况选择使用哪一种：</p><ul><li><strong>FnOnce</strong>：当 <a href="#closure">closure</a> 只能被执行一次时使用<li><strong>FnMut</strong>：当 <a href="#closure">closure</a> 会对值（通过 borrow 或者 move 拿到的值）进行修改时使用<li><strong>Fn</strong>：当 <a href="#closure">closure</a> 不会对值（通过 borrow 或者 move 拿到的值）进行修改时使用</ul><p>一个 Fn Mut 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">// 这个 closure（incr）就是一个 FnMut：borrow 了 外部值 i 的可变引用</span>
<span class="c1">// 所以要在 incr 前面加一个 mut</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">incr</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// incr borrows a mut reference to i</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"Ding! i is now: {}"</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>总结：</p><ul><li><strong>Fn closure</strong>：没有限制，可以被调用多次。而且所有普通的函数类型：fn 也都是 Fn<li><strong>FnMut closure</strong>：可以被调用多次，但使用的时候，需要用 mut 标明该 <a href="#closure">closure</a><li><strong>FnOnce closure</strong>：只能被调用一次</ul><blockquote><p>这 3 种类型的 <a href="#closure">closure</a> 使用限制一个比一个严格，它们的从属关系是：Fn 是 FnMut 的子 trait；FnMut 是 FnOnce 的子 trait。</p></blockquote><h2 id="iterator"><span class="mr-2">Iterator</span><a href="#iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><h3 id="概念"><span class="mr-2">概念</span><a href="#概念" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>先明确几个概念：</p><ul><li>所谓 <a href="#iterator">Iterator</a> 就是实现了 <code class="language-plaintext highlighter-rouge">Iterator</code> trait 的「类型」。<li>「某个类型可迭代」（<strong>iterable</strong>）就是指该类型实现了 <code class="language-plaintext highlighter-rouge">IntoIterator</code>，也就是对这个「类型」可以通过 <code class="language-plaintext highlighter-rouge">into_iter()</code> 方法获取到「该类型对应的 iterator」。从而可以通过 <a href="#iterator">Iterator</a> 来做遍历操作<ul><li><a href="#iterator">Iterator</a> 生产（produces）「值」<li>获取到 <a href="#iterator">Iterator</a> 生产（produces）的「值」的代码就是「消费者」（consumer）</ul></ul><blockquote><p>for 循环会自动调用「可迭代类型」的 into_iter 获取 iterator；不过也可以直接把一个 iterator 给 for 循环语句：iterator 本身也可以被调用 into_iter 方法（返回 iterator 自己）</p></blockquote><p>参考下面 for 循环的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span>

    <span class="c1">// 实际上 for 并不是作用在 v 上的，实际上是作用在一个 iterator 上的</span>
    <span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">v</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>实际上 for 并不是作用在 v 上的，实际上是作用在一个 iterator 上的，for 语句会自动调用 vector 的 into_iter 方法：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span>

    <span class="c1">// 显示的调用 vector 的 into_iter 方法返回一个 iterator，</span>
    <span class="c1">// 按前面说的，for 语句也可以直接接收 iterator，</span>
    <span class="c1">// 之后会 returns owned item</span>
    <span class="k">for</span> <span class="n">num</span> <span class="k">in</span> <span class="n">v</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// for 语句后 vector 不再有效（其中 item 的 ownership 已经转移）</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面这个例子中，使用了 into_iter 方法后，vector 中 item 的 ownership 已经转移，所以 for 语句后变量 v 不再有效。</p><p>再看一个等价于上面 for 循环的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">];</span>

    <span class="c1">// vector 的 into_iter 方法返回一个 iterator，之后会 returns owned item</span>
    <span class="c1">// 然后使用 for_each 顺序消费这个 iterator 产出的序列中的值</span>
    <span class="n">v</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="n">num</span><span class="p">|</span> <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">num</span><span class="p">));</span>

    <span class="c1">// vector 不再有效（其中 item 的 ownership 已经转移）</span>
<span class="p">}</span>
</pre></table></code></div></div><hr /><p>再简单介绍一下 <strong>迭代器 Trait</strong>（iterator trait）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">trait</span> <span class="nb">Iterator</span> <span class="p">{</span>
        <span class="c1">// 这里的 Item 类型是 Iterator 返回的序列中元素的类型</span>
        <span class="k">type</span> <span class="n">Item</span><span class="p">;</span>

        <span class="c1">// Next 一次返回迭代器中的一项，封装在 Some 中，当迭代器结束时，它返回 None</span>
        <span class="k">fn</span> <span class="nf">next</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="k">Self</span><span class="p">::</span><span class="n">Item</span><span class="o">&gt;</span><span class="p">;</span>

        <span class="c1">// 此处省略了方法的默认实现</span>
    <span class="p">}</span>
<span class="p">}</span>

</pre></table></code></div></div><ul><li>注意：next 需要一个可变引用（&amp;mut）；也就是说，每次调用 next 会消费（consume）该序列中的一项，实际上 iterator 的状态被改变（mut）了<li>Rust 中的很多集合类型（比如前面例子中的 vector），会默认实现另外一个 trait：IntoIterator，然后就可以调用这个 trait 的方法 into_iter 得到这个集合上的 iterator</ul><h3 id="获取-iterator"><span class="mr-2">获取 iterator</span><a href="#获取-iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Rust 的标准库为了方便开发者，为各个「Collect 类型」提供了多种 <a href="#iterator">Iterator</a>。</p><p>其中，为大多数 Collect 类型提供了另外 <strong>2 个方法</strong>来获取 iterator：</p><ul><li><strong>iter()</strong> 方法：返回的 iterator 获取到序列中 item 的<strong>不变引用</strong>，对 item 只读不修改（不转移 item 的 ownership）<li><strong>iter_mut()</strong> 方法：返回的 iterator 获取到序列中 item 的<strong>可变引用</strong>，可以修改 item（不转移 item 的 ownership）</ul><p>一个在 vector 类型上使用 <code class="language-plaintext highlighter-rouge">iter()</code> 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
    <span class="c1">// iterator 本身可变（mut），但处理其中的 item 时，是一个不变引用：&amp;i32</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.iter</span><span class="p">();</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">4</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">20</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">12</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">8</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="nf">.next</span><span class="p">(),</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="mi">6</span><span class="p">));</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">iterator</span><span class="nf">.next</span><span class="p">(),</span> <span class="nb">None</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><blockquote><p>总之，大多数场景下，<code class="language-plaintext highlighter-rouge">iter()</code> 方法可以遍历使用 item 的「引用」。但到具体某个「Collect 类型」是不是确实是返回 item 的「引用」可以参考文档。</p></blockquote><p>另外，要拿到某个类型的 <a href="#iterator">Iterator</a>，也可以直接调用 <code class="language-plaintext highlighter-rouge">into_iter()</code> 方法。当如先需要查询文档确认该「类型」是否实现了 <strong>IntoIterator Trait</strong>）。其中大多数「Collect 类型」都实现了几种 <strong>IntoIterator Trait</strong>，例如：</p><ul><li>&amp;T：只读，不转移 ownership。<strong>在「不变引用」上调用 into_iter()</strong> 的场景<li>&amp;mut T：读写，不转移 ownership。<strong>通常在「可变引用」上调用 into_iter()</strong> 的场景。比如常用的 <code class="language-plaintext highlighter-rouge">(&amp;mut vector).into_iter()</code><li>T：转移 ownership。例如：<strong>直接通过「值」来调用 into_iter() 的场景</strong></ul><p>总之，通常在不同的场景可以使用 3 种调用 <code class="language-plaintext highlighter-rouge">into_iter()</code> 的方式（不过具体还是要查文档）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">collection</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">collection</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">for</span> <span class="n">element</span> <span class="k">in</span> <span class="n">collection</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</pre></table></code></div></div><h3 id="使用-iterator"><span class="mr-2">使用 iterator</span><a href="#使用-iterator" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>使用 iterator 需要 Iterator Consumer 和 Iterator Adaptor。</p><ul><li>Iterator Consumer：可以通过 Iterator Consumer 不断调用 next() 方法，对一个 iterator 进行消费。例如：<ul><li>sum，max，min<li>fold<li>for_each<li>collect</ul></ul><p>参考具体文档熟悉更多的 consumer。</p><ul><li>Iterator Adaptor：把当前 iterator 变为另外类型的 iterator。例如：<ul><li>map<li>filter<li>filter_map 和 flat_map</ul></ul><p>参考具体文档熟悉更多的 Iterator Adaptor。</p><h4 id="map"><span class="mr-2">map</span><a href="#map" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p><a href="#map">map</a> 通过对 <a href="#iterator">iterator</a> 的 items 实施一个 closure 来对 <a href="#iterator">iterator</a> 进行转换。</p><p>一个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// str::trim 作用到 iterator 的 items 上，转换出另外一个 iterator</span>
<span class="c1">// 最后再调用 collect() 把 iterator 转换为 vector</span>
<span class="k">let</span> <span class="n">text</span> <span class="o">=</span> <span class="s">" ponies </span><span class="se">\n</span><span class="s"> giraffes</span><span class="se">\n</span><span class="s">iguanas </span><span class="se">\n</span><span class="s">squid"</span><span class="nf">.to_string</span><span class="p">();</span>
<span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">text</span><span class="nf">.lines</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">trim</span><span class="p">)</span>
    <span class="nf">.collect</span><span class="p">();</span>

<span class="nd">assert_eq!</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[</span><span class="s">"ponies"</span><span class="p">,</span> <span class="s">"giraffes"</span><span class="p">,</span> <span class="s">"iguanas"</span><span class="p">,</span> <span class="s">"squid"</span><span class="p">]);</span>
</pre></table></code></div></div><h4 id="flattern"><span class="mr-2">flattern</span><a href="#flattern" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>对 <a href="#iterator">iterator</a> 使用 <a href="#flattern">flattern</a> 的前提是这个 <a href="#iterator">iterator</a> 中的 item 实现了 IntoIterator（也就是可以把 item 转成 <a href="#iterator">iterator</a>）</p><p>这样，就可以利用 <a href="#flattern">flattern</a> 用来把一个 中的所有 items 「拉平」，从「二维」转换成「一维」。</p><p>例如，Option 已经实现了 IntoIterator，那么我们可以这样使用 <a href="#flattern">flattern</a> ：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">assert_eq!</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="s">"day"</span><span class="p">),</span> <span class="nb">None</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="s">"one"</span><span class="p">)]</span>
               <span class="nf">.into_iter</span><span class="p">()</span>
               <span class="nf">.flatten</span><span class="p">()</span>
               <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
               <span class="nd">vec!</span><span class="p">[</span><span class="s">"day"</span><span class="p">,</span> <span class="s">"one"</span><span class="p">]);</span>
</pre></table></code></div></div><h2 id="macros"><span class="mr-2">macros</span><a href="#macros" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust 中的宏分以下几种：</p><ul><li>declarative macros：使用 macro_rules! 来定义宏（据说未来会有更好的机制来替换 macro_rules!）<li>procedural macros。翻译成「过程宏」，用代码生成代码。又分成 3 种：<ul><li>derive。derive 只能用于结构体和枚举<li>attribute（Attribute-like）。可以用于任何地方。<li>function（function-like）</ul></ul><h3 id="macro-rules"><span class="mr-2">macro rules</span><a href="#macro-rules" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>给个例子（利用宏 vec! 来初始化 vector）：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">v</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>vec! 定义如下：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nd">#![allow(unused)]</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nd">#[macro_export]</span>
    <span class="c1">// vec 是宏的名字</span>
    <span class="nd">macro_rules!</span> <span class="n">vec</span> <span class="p">{</span>
      <span class="p">(</span> <span class="nv">$</span><span class="p">(</span> <span class="nv">$x:expr</span> <span class="p">),</span><span class="o">*</span> <span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
          <span class="p">{</span>
              <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
              <span class="nv">$</span><span class="p">(</span>
                  <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="nv">$x</span><span class="p">);</span>
              <span class="p">)</span><span class="o">*</span>
              <span class="n">temp_vec</span>
          <span class="p">}</span>
      <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>需要用 #[macro_export] 属性来标识该宏可用<li>( $( $x:expr ),* ) 用于模式匹配。例如，可以匹配上面例子中的：[1, 2, 3] 会被匹配出 3 个值：1、2、3，对应到宏定义中的 $x<li>=&gt; 类似 match 语句，当模式匹配成功以后，就执行 =&gt; 后面的代码</ul><p>最终，会生成类似以下的代码：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">temp_vec</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">temp_vec</span><span class="nf">.push</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="n">temp_vec</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="unsafe"><span class="mr-2">unsafe</span><a href="#unsafe" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h2></h2><p>Rust 里面可以通过 2 种方法来标明代码是 unsafe 代码：unsafe block 和 unsafe function。</p><h3 id="unsafe-block"><span class="mr-2">Unsafe Block</span><a href="#unsafe-block" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>把 unsafe 关键字放在 block 代码块之前，就标明了一块 unsafe block：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="n">ascii</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>如果这个代码块前面没有 unsafe 关键字，Rust 编译的时候会提示失败：from_utf8_unchecked 方法只能在 unsafe 下被使用。</p><p>unsafe block 解锁了 5 个限制：</p><ul><li>可以在 unsafe block 内使用 unsafe 函数<li>可以 defer raw 指针<li>可以存取 union 中的字段<li>可以存取「可变 static 变量」（但这样需要由你自己来保证该变量的线程安全）<li>可以存取由 Rust「外部函数接口」（FFI）定义的函数和变量</ul><p>一旦使用了 unsafe block 也就是提醒开发人员注意，这部分代码的安全性不再由 Rust 来保证了：</p><ul><li>避免随意用了 unsafe block，但又完全不了解 block 中的风险所在<li>在做 code review 时，需要把 unsafe block 特别标注出来，特别对待<li>在打算使用一个 unsafe block 之前，先自己确认一下是否是真的需要使用 unsafe。例如，如果是出于更好性能考虑，先调研一下，是否真的能提升性能，或者是否存在 Rust safe 的方案来同样达到提升性能的目的</ul><p>给一个 unsafe block 的例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="k">mod</span> <span class="n">my_ascii</span> <span class="p">{</span>
    <span class="cd">/// An ASCII-encoded string. </span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">Ascii</span><span class="p">(</span>
        <span class="c1">// This must hold only well-formed ASCII text: </span>
        <span class="c1">// bytes from `0` to `0x7f`.</span>
        <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span>
    <span class="p">);</span>

    <span class="k">impl</span> <span class="n">Ascii</span> <span class="p">{</span>
        <span class="cd">/// Create an `Ascii` from the ASCII text in `bytes`. Return a</span>
        <span class="cd">/// `NotAsciiError` error if `bytes` contains any non-ASCII</span>
        <span class="cd">/// characters.</span>
        <span class="cd">/// 这里保证了数据的正确，一旦数据不是 ASCII 格式，抛 Err</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_bytes</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Result</span><span class="o">&lt;</span><span class="n">Ascii</span><span class="p">,</span> <span class="n">NotAsciiError</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">bytes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.any</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">byte</span><span class="p">|</span> <span class="o">!</span><span class="n">byte</span><span class="nf">.is_ascii</span><span class="p">())</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nf">Err</span><span class="p">(</span><span class="nf">NotAsciiError</span><span class="p">(</span><span class="n">bytes</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="nf">Ok</span><span class="p">(</span><span class="nf">Ascii</span><span class="p">(</span><span class="n">bytes</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// When conversion fails, we give back the vector we couldn't convert. </span>
    <span class="c1">// This should implement `std::error::Error`; omitted for brevity. </span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">Eq,</span> <span class="nd">PartialEq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">NotAsciiError</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="c1">// Safe, efficient conversion, implemented using unsafe code.</span>
    <span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">Ascii</span><span class="o">&gt;</span> <span class="k">for</span> <span class="nb">String</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">ascii</span><span class="p">:</span> <span class="n">Ascii</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">String</span> <span class="p">{</span>
            <span class="c1">// If this module has no bugs, this is safe, because </span>
            <span class="c1">// well-formed ASCII text is also well-formed UTF-8. </span>
            <span class="c1">// 这里由程序员保证 unsafe block 的安全：这里 使用 unsafe 函数 from_utf8_unchecked 是安全的</span>
            <span class="c1">// 因为如果是 ASCII，也就是 UTF-8</span>
            <span class="k">unsafe</span> <span class="p">{</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_unchecked</span><span class="p">(</span><span class="n">ascii</span><span class="na">.0</span><span class="p">)</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Ascii 类型可以被使用在 safe 的环境，例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">my_ascii</span><span class="p">::</span><span class="n">Ascii</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">bytes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span> <span class="o">=</span> <span class="s">b"ASCII and ye shall receive"</span><span class="nf">.to_vec</span><span class="p">();</span>
    <span class="c1">// This call entails no allocation or text copies, just a scan.</span>
    <span class="k">let</span> <span class="n">ascii</span><span class="p">:</span> <span class="n">Ascii</span> <span class="o">=</span> <span class="nn">Ascii</span><span class="p">::</span><span class="nf">from_bytes</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// We know these chosen bytes are ok.</span>
    <span class="c1">// This call is zero-cost: no allocation, copies, or scans.</span>
    <span class="k">let</span> <span class="n">string</span> <span class="o">=</span> <span class="nn">String</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">ascii</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="s">"ASCII and ye shall receive"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="unsafe-function"><span class="mr-2">Unsafe Function</span><a href="#unsafe-function" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Unsafe Function：</p><ul><li>函数定义前面加一个 unsafe 关键字，就定义一个 unsafe function。unsafe function 的函数体就是一个 unsafe block<li>只能在 unsafe block 里面调用 unsafe function<li>一旦定义了一个 unsafe function，就是告诉它的调用者必须按照约定来调用该函数，否则就可能出现 UB</ul><p>给个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// This must be placed inside the `my_ascii` module.</span>
<span class="k">impl</span> <span class="n">Ascii</span> <span class="p">{</span>
    <span class="cd">/// Construct an `Ascii` value from `bytes`, without checking</span>
    <span class="cd">/// whether `bytes` actually contains well-formed ASCII.</span>
    <span class="cd">///</span>
    <span class="cd">/// This constructor is infallible, and returns an `Ascii` directly, </span>
    <span class="cd">/// rather than a `Result&lt;Ascii, NotAsciiError&gt;` as the `from_bytes` /// constructor does.</span>
    <span class="cd">///</span>
    <span class="cd">/// # Safety</span>
    <span class="cd">///</span>
    <span class="cd">/// The caller must ensure that `bytes` contains only ASCII</span>
    <span class="cd">/// characters: bytes no greater than 0x7f. Otherwise, the effect is </span>
    <span class="cd">/// undefined.</span>
    <span class="cd">/// 也就是说，必须由调用者来保证安全性。</span>
    <span class="cd">/// 由调用者来保证这个 Safety 声明：bytes 参数必须是合法的 ASCII 字符串</span>
    <span class="k">pub</span> <span class="k">unsafe</span> <span class="k">fn</span> <span class="nf">from_bytes_unchecked</span><span class="p">(</span><span class="n">bytes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Ascii</span> <span class="p">{</span>
        <span class="nf">Ascii</span><span class="p">(</span><span class="n">bytes</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>2 个关键事实：</p><ul><li>在进入 unsafe block 之前的代码如果存在 bug，可能就会破坏协议；也就是说，协议被破坏，可能的原因不单是 unsafe block 本身里面有问题，unsafe block 之前的代码存在问题也会破坏协议<li>如果出现了 UB，UB 引起的问题不一定在 unsafe block 中爆出来，而是有可能在 unsafe block 之后才爆出来</ul><blockquote><p>一旦使用了 unsafe block，就是告诉 Rust：信任我，我保证所有都 OK。</p><p>但这种「保证」依赖所有会影响 unsafe block 的因素是否 OK。</p><p>同时，一旦出现 UB，UB 引发的问题可能出现在任何被这个 unsafe block 影响的地方。</p></blockquote><p>使用 unsafe block，还是使用 unsafe function？</p><p>如果能保证只要正常使用就不会破坏 Rust 的安全性，就不需要指明函数是 unsafe 的。否则，才需要使用 unsafe function，并提供安全协议给其调用者。</p><h3 id="unsafe-trait"><span class="mr-2">Unsafe Trait</span><a href="#unsafe-trait" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Unsafe Trait：如果一个 trait，需要在实现时遵循一个「契约」，同时这个「契约」需要开发者来保证，而 Rust 不能 check 这个「契约」；那么这个 trait 就是 Unsafe Trait：</p><ul><li>在实现 Unsafe Trait 时，必须把实现标为 unsafe 的<li>如果把一个函数的类型变量绑定到一个 Unsafe Trait 上，那么这个函数本身也肯定是 unsafe。而这个 unsafe 函数的「契约」肯定就会和 Unsafe Trait 的「契约」相关联<li>一个例子：std::marker::Send 就是一个 Unsafe Trait，而且 std::marker::Send 不会有任何方法，这个 trait 只是用来标记实现了这个 trait 的类型必须满足能被安全移动到其他线程的「契约」</ul><h3 id="raw-pointer"><span class="mr-2">Raw Pointer</span><a href="#raw-pointer" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h3></h3><p>Rust 中有 2 类 Raw Pointers：</p><ul><li><code class="language-plaintext highlighter-rouge">*mut T</code>：允许修改该指针指向的数据<li><code class="language-plaintext highlighter-rouge">*const T</code>：只能读取该指针指向的数据，不能通过这个指针修改其指向的数据</ul><p>通过对「引用」进行转换来创建 Raw Pointer，然后用 * 操作符来对 Raw Pointer 做「解引用」。例如：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="c1">// 把 &amp;mut 转成 *mut</span>
    <span class="k">let</span> <span class="n">ptr_x</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">x</span> <span class="k">as</span> <span class="o">*</span><span class="k">mut</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">y</span> <span class="o">=</span> <span class="nn">Box</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
    <span class="c1">// 先把 y 解成 *y，然后把 &amp;*y 转换成 *const</span>
    <span class="k">let</span> <span class="n">ptr_y</span> <span class="o">=</span> <span class="o">&amp;*</span><span class="n">y</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="nb">i32</span><span class="p">;</span>

    <span class="c1">// 解 Raw 指针操作必须 unsafe</span>
    <span class="k">unsafe</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">ptr_x</span> <span class="o">+=</span> <span class="o">*</span><span class="n">ptr_y</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>注意：只有对「Raw 指针」进行 dereference（解引用）是 unsafe，其他操作（比如创建 Raw Pointer）是安全的。</p><p>不能再把「Raw 指针」转回成「引用」，只能 borrow 解「Raw 指针」的结果。</p><p>下面看一个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="cd">/// 如果某个类型的值是 2-byte 对齐的，可以使用一个技巧：</span>
<span class="cd">/// 把一个 bool 值（true or false）也存在这个单个值里面。</span>
<span class="k">mod</span> <span class="n">ref_with_flag</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">PhantomData</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="n">align_of</span><span class="p">;</span>

    <span class="cd">/// A `&amp;T` and a `bool`, wrapped up in a single word.</span>
    <span class="cd">/// The type `T` must require at least two-byte alignment.</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">RefWithFlag</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">ptr_and_bit</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">behaves_like</span><span class="p">:</span> <span class="n">PhantomData</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="c1">// behaves_like 字段不占用内存空间</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="p">:</span> <span class="nv">'a</span><span class="o">&gt;</span> <span class="n">RefWithFlag</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">ptr</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">,</span> <span class="n">flag</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RefWithFlag</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
            <span class="c1">// 如果这个类型不是 2-byte 对齐的，直接失败</span>
            <span class="c1">// 如果 %2 为 0 的话，实际上就可以用最后一个 bit 位来存放 bool 是 true 还是 false</span>
            <span class="nd">assert!</span><span class="p">(</span><span class="nn">align_of</span><span class="p">::</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
            <span class="n">RefWithFlag</span> <span class="p">{</span>
                <span class="c1">// ptr 是类型的值的「不可变引用」，borrow 进来的</span>
                <span class="c1">// 把 ptr 转成指向该类型的「不变」raw pointer，再强转成 usize</span>
                <span class="c1">// 把 bool 值也强转成 usize</span>
                <span class="c1">// 然后把这 2 个 usize 的值做「或」操作</span>
                <span class="c1">// 这样就实现了用 raw pointer 的最后一个 bit 位来存放 bool 的值：</span>
                <span class="n">ptr_and_bit</span><span class="p">:</span> <span class="n">ptr</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span> <span class="k">as</span> <span class="nb">usize</span> <span class="p">|</span> <span class="n">flag</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span>
                <span class="n">behaves_like</span><span class="p">:</span> <span class="n">PhantomData</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span> <span class="p">{</span>
            <span class="k">unsafe</span> <span class="p">{</span>
                <span class="c1">// 恢复原先的指针值（恢复最后一个 bit 位）</span>
                <span class="k">let</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="k">self</span><span class="py">.ptr_and_bit</span> <span class="o">&amp;</span> <span class="o">!</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="o">*</span><span class="k">const</span> <span class="n">T</span><span class="p">;</span>
                <span class="c1">// 解引用，恢复原先的类型的值</span>
                <span class="o">&amp;*</span><span class="n">ptr</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_flag</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
            <span class="c1">// 通过最后一个 bit 位的值来获取 bool 是 true 还是 false</span>
            <span class="k">self</span><span class="py">.ptr_and_bit</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 使用 RefWithFlag</span>
<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">ref_with_flag</span><span class="p">::</span><span class="n">RefWithFlag</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">vec</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">];</span>
    <span class="k">let</span> <span class="n">flagged</span> <span class="o">=</span> <span class="nn">RefWithFlag</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vec</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">flagged</span><span class="nf">.get_ref</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">20</span><span class="p">);</span>
    <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">flagged</span><span class="nf">.get_flag</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>上面这个例子的一些细节：</p><ul><li>上面这个技巧首先基于一个事实：raw pointer 和 usize 是可以安全的来回转换的<li>在 get_ref 中，先用 * 操作符对 raw pointer 进行 deference；然后再用一个 &amp; 对这个 deference 的结果进行 borrow<li>Rust 中，对一个指针的 referent 进行 borrow，可以得到一个不受「生命周期」规则约束的「引用」。但给 Rust 标记出精确的「生命周期」能避免引起错误，所以 get_ref 的返回值，标记了其返回值的「生命周期」和 RefWithFlag 的「生命周期」相同：’a<ul><li>A pointer’s referent object is the object that it is intended to reference</ul><li>PhantomData 作为「影子数据」不占用内存空间；但这个例子中的 PhantomData 字段不可或缺，否则编译失败<ul><li>struct 中存在引用字段的话，struct 本身不能存活超过这些引用字段所引用的值的「生命周期」，否则就会产生悬挂指针<li>所以需要以某种方式标记出 struct 本身的「生命周期」必须和其引用字段的「生命周期」相匹配<li>在这个例子中，既然 RefWithFlag 的生命周期不能比 ptr_and_bit 字段的生命周期要长，我们需要对 RefWithFlag 的生命周期进行标记。但又不能对 usize 字段做标记，只能再加一个 PhantomData 引用字段，并把这个字段的生命周期和 RefWithFlag 的生命周期都标记为：’a</ul></ul><p>struct 的生命周期请参考：<a href="#结构体的生命周期注解">结构体的生命周期注解</a></p><h4 id="nullable-pointers"><span class="mr-2">Nullable Pointers</span><a href="#nullable-pointers" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>2 种空指针。分别由 2 个函数返回：</p><ul><li>std::ptr::null&lt;T&gt;：返回 *const T<li>std::ptr::null_mut&lt;T&gt;：返回 *mut T</ul><p>检查一个 raw pointer 是否是空指针的方法有：</p><ul><li>is_null 方法<li>as_ref 方法或 as_mut 方法。分别用于检查 *const T 和 *mut T</ul><h4 id="type-sizes-和-alignments"><span class="mr-2">Type Sizes 和 Alignments</span><a href="#type-sizes-和-alignments" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>使用 unsafe 时也会用到「类型大小」和「类型对齐」相关的知识。</p><p>对于 sized 类型，可以使用下面的方法获取其 size 和 align：</p><ul><li>使用 <code class="language-plaintext highlighter-rouge">std::mem::size_of::&lt;T&gt;()</code> 获取类型的 size<li>使用 <code class="language-plaintext highlighter-rouge">std::mem::align_of::&lt;T&gt;()</code> 获取类型的对齐数</ul><p>类型的 size 一定是该类型的 align 数的整倍数。</p><p>而对于 unsize 的类型，它的 size 大小和 align 数不固定。</p><p>给几个例子：</p><div class="language-rust highlighter-rouge"><div class="code-header"> <span data-label-text="Rust"><i class="fas fa-code small"></i></span> <button aria-label="copy" data-title-succeed="已复制！"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// Fat pointers to slices carry their referent's length.</span>
<span class="k">let</span> <span class="n">slice</span><span class="p">:</span> <span class="o">&amp;</span> <span class="p">[</span><span class="nb">i32</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">81</span><span class="p">];</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="n">slice</span><span class="p">),</span> <span class="mi">20</span><span class="p">);</span>

<span class="k">let</span> <span class="n">text</span><span class="p">:</span> <span class="o">&amp;</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"alligator"</span><span class="p">;</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="mi">9</span><span class="p">);</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">fmt</span><span class="p">::</span><span class="n">Display</span><span class="p">;</span>
<span class="k">let</span> <span class="n">unremarkable</span><span class="p">:</span> <span class="o">&amp;</span> <span class="k">dyn</span> <span class="n">Display</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="mi">193_u8</span><span class="p">;</span>
<span class="k">let</span> <span class="n">remarkable</span><span class="p">:</span> <span class="o">&amp;</span> <span class="k">dyn</span> <span class="n">Display</span> <span class="o">=</span> <span class="o">&amp;</span> <span class="mf">0.0072973525664</span><span class="p">;</span>

<span class="c1">// These return the size/alignment of the value the</span>
<span class="c1">// trait object points to, not those of the trait object</span>
<span class="c1">// itself. This information comes from the vtable the</span>
<span class="c1">// trait object refers to.</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">size_of_val</span><span class="p">(</span><span class="n">unremarkable</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
<span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">std</span><span class="p">::</span><span class="nn">mem</span><span class="p">::</span><span class="nf">align_of_val</span><span class="p">(</span><span class="n">remarkable</span><span class="p">),</span> <span class="mi">8</span><span class="p">);</span>
</pre></table></code></div></div><h4 id="pointer-arithmetic"><span class="mr-2">Pointer Arithmetic</span><a href="#pointer-arithmetic" class="anchor text-muted"><i class="fas fa-hashtag"></i></a></h4></h4><p>原则：在数组中，每个元素占用的 size 是 n，那么第 i 个元素的起始位置是第 <code class="language-plaintext highlighter-rouge">i * n</code> bytes。</p><p>raw 指针上有 2 个方法可以使用：</p><ul><li><code class="language-plaintext highlighter-rouge">ptr.offset(i)</code>：获得 ptr 的偏移量为 i 的指针。这个方法可能引起 UB<li><code class="language-plaintext highlighter-rouge">ptr.wrapping_offset(i)</code>：和 ptr 类似，但 Rust makes no assumptions about the relative ordering of <code class="language-plaintext highlighter-rouge">ptr.wrapping_offset(i)</code> and ptr itself</ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%E7%BC%96%E7%A8%8B/'>编程</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/rust/" class="post-tag no-text-decoration" >rust</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> 本文由作者按照 <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> 进行授权</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">分享</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Rust Notes - Darktea&amp;url=https://darktea.github.io/posts/rust-notes/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Rust Notes - Darktea&amp;u=https://darktea.github.io/posts/rust-notes/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://t.me/share/url?url=https://darktea.github.io/posts/rust-notes/&amp;text=Rust Notes - Darktea" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="分享链接" data-title-succeed="链接已复制！"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted"><div class="access"><div id="access-lastmod" class="post"><div class="panel-heading">最近更新</div><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/rust-notes/">Rust Notes</a><li><a href="/posts/build-system/">Build Systems</a><li><a href="/posts/On-Designing-and-Deploying-Internet-Scale-Services/">On Designing and Deploying Internet-Scale Services</a><li><a href="/posts/URL-Encoding/">URL Encoding</a><li><a href="/posts/memory-manager/">Linux 内存管理</a></ul></div><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> <a class="post-tag" href="/tags/2pc/">2pc</a> <a class="post-tag" href="/tags/autotools/">autotools</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/bazel/">bazel</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/c/">c</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"><div class="panel-heading pl-3 pt-2 mb-2">文章内容</div><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="tail-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>相关文章</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/right/"><div class="card-body"> <em class="timeago small" data-ts="1679587200" > 2023-03-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>右值引用</h3><div class="text-muted small"><p> 按 C++ 标准的发展来梳理出右值引用的概念。但会先复习一下引用的概念。 引用 先复习一下 C++ 中引用的概念： A reference defines an alternative name for an object 引用就是另外一个已经存在的对象的名字的别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ...</p></div></div></a></div><div class="card"> <a href="/posts/chatbot/"><div class="card-body"> <em class="timeago small" data-ts="1670342400" > 2022-12-07 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>chatbot</h3><div class="text-muted small"><p> 对话型应用 对话型应用也既是 chatbot 的中文翻译。 首先，对话型应用是智能应用，是当今最热门的「机器学习」（AI） 技术的典型应用。 所以，chatbot（对话型应用）是「智能应用」。何谓「智能应用」？如下图所示，通过在训练阶段获得的模型来处理真实的数据： flowchart LR A[[Training data]] --&amp;gt;B(ML argorithm) --&amp;gt...</p></div></div></a></div><div class="card"> <a href="/posts/git-ref/"><div class="card-body"> <em class="timeago small" data-ts="1666540800" > 2022-10-24 </em><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Github Markdown</h3><div class="text-muted small"><p> Here’s a tip – if you’re having trouble with your anchor not working due to misspellings or odd characters, simply hover over your heading on Github, then hover or click the link icon that appea...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/URL-Encoding/" class="btn btn-outline-primary" prompt="上一篇"><p>URL Encoding</p></a> <a href="/posts/Jekyll-Chirpy-notes/" class="btn btn-outline-primary" prompt="下一篇"><p>Jekyll-Chirpy notes</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center text-muted"><div class="footer-left"><p class="mb-0"> © 2024 <a href="https://github.com/darktea">darktea</a>. <span data-toggle="tooltip" data-placement="top" title="除非另有说明，本网站上的博客文章均由作者按照知识共享署名 4.0 国际 (CC BY 4.0) 许可协议进行授权。">保留部分权利。</span></p></div><div class="footer-right"><p class="mb-0"> 本站由 <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> 生成，采用 <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> 主题。</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><div id="access-tags"><div class="panel-heading">热门标签</div><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/linux/">linux</a> <a class="post-tag" href="/tags/notes/">notes</a> <a class="post-tag" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a> <a class="post-tag" href="/tags/2pc/">2pc</a> <a class="post-tag" href="/tags/autotools/">autotools</a> <a class="post-tag" href="/tags/bash/">bash</a> <a class="post-tag" href="/tags/bazel/">bazel</a> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/c/">c</a></div></div></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><script src="https://cdn.jsdelivr.net/npm/mermaid@9/dist/mermaid.min.js"></script> <script> $(function() { function updateMermaid(event) { if (event.source === window && event.data && event.data.direction === ModeToggle.ID) { const mode = event.data.message; if (typeof mermaid === "undefined") { return; } let expectedTheme = (mode === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* Re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } let initTheme = "default"; if ($("html[data-mode=dark]").length > 0 || ($("html[data-mode]").length == 0 && window.matchMedia("(prefers-color-scheme: dark)").matches ) ) { initTheme = "dark"; } let mermaidConf = { theme: initTheme /* <default|dark|forest|neutral> */ }; /* Markdown converts to HTML */ $("pre").has("code.language-mermaid").each(function() { let svgCode = $(this).children().html(); $(this).addClass("unloaded"); $(this).after(`<div class=\"mermaid\">${svgCode}</div>`); }); mermaid.initialize(mermaidConf); window.addEventListener("message", updateMermaid); }); </script><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">搜索结果为空</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/lozad/dist/lozad.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/dayjs@1/dayjs.min.js,npm/dayjs@1/locale/zh.min.js,npm/dayjs@1/plugin/relativeTime.min.js,npm/dayjs@1/plugin/localizedFormat.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.bundle.min.js"></script> <script defer src="/app.js"></script>
